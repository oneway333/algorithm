Nodejs

编写XXX.js文件，通过 node XXX.js/XXX  来运行文件

* 什么是NodeJS？
Node.js是一个基于 Chrome V8引擎的JavaScript运行环境

* Node.js中的JavaScript运行环境
NodeJs中分为两部分，一部分是V8引擎为了解析和执行JS代码。另一部分是内置API，内置API提供了一些能力，让我们JS能调用这些API完成一些后端执行的事情。

ps：浏览器是JavaScript的前端运行环境，Node.js是JavaScript的后端的运行环境

* Node.js可以做什么
Nodejs 作为一个JavaScript的运行环境，仅仅提供了基础的功能和API。然而，基于Node.js 提供的这些基础能，很多强大的“工具和框架”如雨后春笋，层出不穷，所以学会了Node.js，可以让前端程序员胜任“更多的工作和岗位”。

1.基于 Express 框架(http://www.expressjs.com.cn/) 可以快速构建Web应用
2.基于 Electron 框架(https://electronjs.org/) 可以构建跨平台的桌面应用
3.基于 restify 框架(http://restify.com/) 可以快速构建API接口项目
4.读写和操作数据库、创建实用的命令行工具辅助前端开发、等…

* Node.js学习路径

JavaScript 基础语法＋Node.js 内置API模块(fs、path、http等)＋第三方API模块(express、mysql等)

* 使用Node运行JS代码

** 打开终端

** 切换到所要执行的js文件目录（也可以直接在文件目录下输入cmd回车，或者在改目录下按住Shtft鼠标右键，打开powerShell命令行工具）

** 输入 node 要执行的js文件名字.js


* fs模块读写操作文件

** 什么是fs文件系统模块
fs 模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。

例如：

fs.readFile()方法，用于读取指定文件中的内容。
fs.writeFile()方法，用于向执行的文件中写入内容
如果要在javascript代码中使用fs模块来操作文件，则需要使用如下的方式先导入它：

const fs = require('fs')


** 读取指定文件中的内容

fs.readFile()的语法格式
使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下：

fs.readFile(path[, options], callback)

【ps：被中括号包起来的参数均为可选参数项】

path：必选参数，字符串，表示文件路径。
options：可选参数，表示以什么编码格式来读取文件。
callback：必选参数，文件读取完成后，通过"回调函数"拿到读取的结果。


// 1．导入fs模块，来操作文件
const fs = require("fs")
// 2.调用fs.readFile()方法读取文件
//     参数1:读取文件的存放路径
//     参数2:读取文件时候采用的编码格式，一般"默认指定utf8"
//     参数3:回调函数，拿到读取失败和成功的结果 err dataStr
fs.readFile('./test/readFile.txt', 'utf8', function(err, dataStr){
    // 打印失败的结果
    console.log(err)
    console.log("<--------------------------------------------->")
    // 打印成功的结果
    console.log(dataStr)
})

如果读取成功，那么err的值就是null，dataStr的值就是文件的内容

读取失败时err会返回错误对象，dataStr会返回undefined:

node:internal/modules/cjs/loader:1078
  throw err;
  ^

Error: Cannot find module 'D:\nodejs\fuck1.js'
[90m    at Module._resolveFilename (node:internal/modules/cjs/loader:1075:15)[39m
[90m    at Module._load (node:internal/modules/cjs/loader:920:27)[39m
[90m    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)[39m
[90m    at node:internal/main/run_main_module:23:47[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: []
}

Node.js v18.14.2


判断文件是否读取成功
可以判断err对象是否为null，从而知晓文件读取的结果。

// 1．导入fs模块，来操作文件
const fs = require("fs")
// 2.调用fs.readFile()方法读取文件
fs.readFile('./test/readFiles.txt', 'utf8', function(err, result){
    if (err){
        console.log('文件读取失败~' + err.message)
        return 
    }
    console.log('文件读取成功，内容是：' + result)
})


** 向指定的文件中写入文件内容

fs.writeFile()的语法格式
使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下：

fs.writeFile(file, data[, options], callback)

file∶必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。

data：必选参数，表示要写入的内容。

options：可选参数，表示以什么格式写入文件内容，默认值是utf8。

callback：必选参数，文件写入完成后的回调函数。

// 1．导入fs文件系统模块
const fs = require("fs")
// 2.调用fs.writeFile()方法，写入文件内容
//     参数1:读取文件的存放路径
//     参数2:data：表示要写入的内容。
//     参数3:表示以什么格式写入文件内容，默认值是utf8。
//     参数4:文件写入完成后的回调函数。
fs.writeFile('./test/writeFile.txt', "HolleWorld", 'utf8', function(err){
    // 打印失败的结果
    console.log(err)
})


判断文件是否写入成功
可以判断err对象是否为null，从而知晓文件写入的结果。（当要写入的文件的文件夹盘符不存在，比如z盘那就会报错。

const fs = require("fs")
fs.writeFile('x/test/writeFile.txt', "HolleWorld", 'utf8', function(err){
    if(err){
        console.log('文件写入失败！' + err.message)
        return
    }
    console.log('文件写入成功')
})


** fs模块-路径动态拼接问题
相对路径
在使用 fs 模块操作文件时，如果提供的操作路径是以/或…/开头的相对路径时，很容易出现路径动态拼接错误的问题。
原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径。

最终呈现的路径就是执行node命令时的目录+代码中写的路径，所以在不同路径下执行js文件效果都不一样

绝对路径
移植性差

解决办法
__dirname：表示当前js文件所处的目录

console.log('__dirname', __dirname) 结果： __dirname D:\nodejs



* path模块处理路径

** 什么是path路径模块
path模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。

例如:

path.join()方法，用来将多个路径片段拼接成一个完整的路径字符串

path.basename()方法，用来从路径字符串中，将文件名解析出来

如果要在JavaScript 代码中，使用path模块来处理路径，则需要使用如下的方式先导入它：

const path = require('path')

** 路径拼接

1：path.join()的语法格式
使用path.join()方法，可以讲多个路径片段拼接为一个完整的路径字符串，语法格式如下：

path.join([...paths])

参数解读：

…paths 路径片段的序列

返回值 string


2：path.join()代码示例
注意在合成路径的时候，'…/'会抵消掉一层路径

const path = require('path')

const pathStr = path.join('/a', '/b/c', '../', './d', 'e')
console.log(pathStr)        \a\b\d\e，因为../的缘故，c被顶掉了

const pathStr2 = path.join(__dirname, './files/1212.txt')
console.log(pathStr2)       D:\nodejs\files\1212.txt


注意：今后凡是涉及到路径拼接的操作，都要使用path.join()方法进行处理。不要直接使用＋进行字符串的拼接。


** 获取路径中的文件名

path.basename()的语法格式
使用path.basename()方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下:

path.basename(path[, ext])

参数解读:

path ：必选参数，表示一个路径的字符串

ext ：可选参数，表示文件扩展名

返回值：表示路径中的最后一部分

const path = require('path')

const fpath = '/a/b/c/index.html'
var fullName = path.basename(fpath)
console.log(fullName)       index.html

var namewithoutExt = path.basename(fpath, ".html")
console.log(namewithoutExt)     index


** 获取路径中的文件扩展名

path.extname()的语法格式
使用path.extname()方法，可以获取路径中的扩展名部分，语法格式如下：

path.extname(path)

参数解读：

path：必选参数，表示一个路径的字符串

返回：返回得到的扩展名字符串

path.extname()代码示例
使用path.extname()方法，可以获取路径中的扩展名部分

（2）path.extname()代码示例
使用path.extname()方法，可以获取路径中的扩展名部分

const path = require('path')

const fpath = '/a/b/c/index.html'
const fext = path.extname(fpath)
console.log(fext)       .html


* 使用Http模块写一个Web服务器

** 什么是http模块

回顾:什么是客户端、什么是服务器?
在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务

http模块是Node,js官方提供的、用来创建web服务器的模块。通过 http模块提供的 http.createServer()方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。

如果要希望使用http模块创建Web服务器，则需要先导入它:

const http = require( 'http')

** 进一步理解http模块的作用

如何把一个普通电脑变成服务器
服务器和普通电脑的"区别"在于，服务器上安装了web服务器"软件"，例如:IlS、Apache等。通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器。

在Node.js中，我们不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于Node.提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web 服务。

** 服务器相关的概念
1：IP地址
IP地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方IP地址的前提下，才能与对应的电脑之间进行数据通信。

IP地址的格式:通常用“点分十进制”表示成(a.b.c.d)的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如：用点分十进表示的IP地址(192.168.1.1)

注意：
1.互联网中每台Web服务器，都有自己的IP地址
2.例如:大家可以在Windows 的终端中运行【ping www.baidu.com】命令，即可查看到百度服务器的IP地址。
3.在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当做一台服务器进行访问了。

注意:
单纯使用IP地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。
在开发测试期间，127.0.0.1对应的域名是localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。

端口号：大楼里面的小房间
计算机中的端口号，就好像是现实生活中的门牌号一样。通过"门牌号"，外卖小哥可以在整栋大楼(服务器)众多的房间中，准确把外卖送到你的手中。

同样的道理，在一台电脑中，可以运行成百上千个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的web服务进行处理。

注意:
1.每个端口号不能同时被多个web服务占用。一个小房间只能提供一种服务
2.在实际应用中，URL中的80端口可以被省略。

** 创建最基本的web服务器
创建Web服务器步骤
1.导入http模块
2.创建web 服务器实例
3.为服务器实例“绑定request事件”，监听客户端的请求
4.启动服务器

步骤一：导入http模块
如果希望在自己电脑上创建一个web服务器，从而对外提供web服务，则需要导入http模块。

const http = require('http')

步骤二：创建web服务器实例
调用 http.createServer()方法，即可快速创建一个Web服务器实例：

const server = http.createServer()

步骤三：为服务器实例绑定request事件
为服务器实例绑定request事件，即可监听客户端发送过来的网络请求:

// 使用服务器实例的.on()方法，为服务器绑定一个request事件
// 全局事件总线好像就是这个的灵感吧
server.on( 'request', (req,res) => {
    // 只要有客户端来请求我们自己的服务器，就会触发request 事件，从而调用这个事件处理函数
    console.log( 'Someone visit our web server.' )
})


步骤四：启动服务器
调用服务器实例的.listen()方法，即可启动当前的web 服务器实例:

// 调用server.listen(端口号，cb回调）方法，即可启动web 服务器
server.listen(80, () =>{
console.log('http server running at http://127.0.0.1')
})


创建Web服务器示例：

// 导入http模块
const http = require('http')
// 创建web 服务器实例
const server = http.createServer()
// 为服务器实例绑定request事件，监听客户端的请求
server.on( 'request', (req,res) => {
    // 只要有客户端来请求我们自己的服务器，就会触发request 事件，从而调用这个事件处理函数
    console.log( 'Someone visit our web server.' )
})

// 启动服务器
server.listen(8080, () =>{
    console.log('http server running at http://127.0.0.1:8080')
})

req请求对象

只要服务器接收到了客户端的请求，就会调用通过server.on()为服务器绑定的request事件处理函数。
如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式:

server.on( 'request', (req) =>{
    // req是请求对象，它包含了与客户端相关的数据和属性，例如:3 ll req.url是客户端请求的URL地址
    // req.method是客户端的 method请求类型
    const str = `Your request url is ${req.url}，and request method is ${req.method}`
    console.log(str)
})

完整代码：

const http = require('http')
const server = http.createServer()

server.on( 'request', (req) =>{
    // req是请求对象，它包含了与客户端相关的数据和属性，例如:3 ll req.url是客户端请求的URL地址
    // req.method是客户端的 method请求类型
    const str = `Your request url is ${req.url}，and request method is ${req.method}`
    console.log(str)
})

server.listen(8080, () =>{
    console.log('http server running at http://127.0.0.1:8080')
})


res响应对象

在服务器的request事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式:

server.on( 'request ', (req, res) => {
    // res是响应对象，它包含了与服务器相关的数据和属性，例如:31/要发送到客户端的字符串
    const str = `Your request url is ${req.url}，and request method is ${req.method}`
    // res.end()方法的作用:
    // 向客户端发送指定的内容，并结束这次请求的处理过程
    res.end(str)
})


完整代码：

const http = require('http')
const server = http.createServer()

server.on( 'request', (req, res) =>{
    // req.method是客户端的 method请求类型
    const str = `Your request url is ${req.url}，and request method is ${req.method}`
    console.log(str)
    // 调用 res.end()方法，向客户端响应一些内容
    res.end(str)
})

server.listen(8080, () =>{
    console.log('http server running at http://127.0.0.1:8080')
})


解决中文乱码问题
当调用res.end()方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式:

server.on('request', (req,res) => {
    //发送的内容包含中文
    const str =`您请求的url地址是${req.url}，请求的 method类型是${req.method}`
    // 为了防止中文显示乱码的问题，需要设置响应头Content-Type 的值为 text/html; charset=utf-8
    res.setHeader( 'Content-Type',  'text/html; charset=utf-8')
    // 把包含中文的内容，响应给客户端
    res.end(str)
})



const http = require('http')
const server = http.createServer()
server.on('request', (req,res) => {
    //发送的内容包含中文
    const str =`您请求的url地址是${req.url}，请求的 method类型是${req.method}`
    // 为了防止中文显示乱码的问题，需要设置响应头Content-Type 的值为 text/html; charset=utf-8
    res.setHeader( 'Content-Type',  'text/html; charset=utf-8')
    // 把包含中文的内容，响应给客户端
    res.end(str)
})
server.listen(8080, () =>{
    console.log('http server running at http://127.0.0.1:8080')
})




























