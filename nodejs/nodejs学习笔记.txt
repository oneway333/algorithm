Nodejs

编写XXX.js文件，通过 node XXX.js/XXX  来运行文件

* 什么是NodeJS？
Node.js是一个基于 Chrome V8引擎的JavaScript运行环境

* Node.js中的JavaScript运行环境
NodeJs中分为两部分，一部分是V8引擎为了解析和执行JS代码。另一部分是内置API，内置API提供了一些能力，让我们JS能调用这些API完成一些后端执行的事情。

ps：浏览器是JavaScript的前端运行环境，Node.js是JavaScript的后端的运行环境

* Node.js可以做什么
Nodejs 作为一个JavaScript的运行环境，仅仅提供了基础的功能和API。然而，基于Node.js 提供的这些基础能，很多强大的“工具和框架”如雨后春笋，层出不穷，所以学会了Node.js，可以让前端程序员胜任“更多的工作和岗位”。

1.基于 Express 框架(http://www.expressjs.com.cn/) 可以快速构建Web应用
2.基于 Electron 框架(https://electronjs.org/) 可以构建跨平台的桌面应用
3.基于 restify 框架(http://restify.com/) 可以快速构建API接口项目
4.读写和操作数据库、创建实用的命令行工具辅助前端开发、等…

* Node.js学习路径

JavaScript 基础语法＋Node.js 内置API模块(fs、path、http等)＋第三方API模块(express、mysql等)

* 使用Node运行JS代码

** 打开终端

** 切换到所要执行的js文件目录（也可以直接在文件目录下输入cmd回车，或者在改目录下按住Shtft鼠标右键，打开powerShell命令行工具）

** 输入 node 要执行的js文件名字.js


* fs模块读写操作文件

** 什么是fs文件系统模块
fs 模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。

例如：

fs.readFile()方法，用于读取指定文件中的内容。
fs.writeFile()方法，用于向执行的文件中写入内容
如果要在javascript代码中使用fs模块来操作文件，则需要使用如下的方式先导入它：

const fs = require('fs')


** 读取指定文件中的内容

fs.readFile()的语法格式
使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下：

fs.readFile(path[, options], callback)

【ps：被中括号包起来的参数均为可选参数项】

path：必选参数，字符串，表示文件路径。
options：可选参数，表示以什么编码格式来读取文件。
callback：必选参数，文件读取完成后，通过"回调函数"拿到读取的结果。


// 1．导入fs模块，来操作文件
const fs = require("fs")
// 2.调用fs.readFile()方法读取文件
//     参数1:读取文件的存放路径
//     参数2:读取文件时候采用的编码格式，一般"默认指定utf8"
//     参数3:回调函数，拿到读取失败和成功的结果 err dataStr
fs.readFile('./test/readFile.txt', 'utf8', function(err, dataStr){
    // 打印失败的结果
    console.log(err)
    console.log("<--------------------------------------------->")
    // 打印成功的结果
    console.log(dataStr)
})

如果读取成功，那么err的值就是null，dataStr的值就是文件的内容

读取失败时err会返回错误对象，dataStr会返回undefined:

node:internal/modules/cjs/loader:1078
  throw err;
  ^

Error: Cannot find module 'D:\nodejs\fuck1.js'
[90m    at Module._resolveFilename (node:internal/modules/cjs/loader:1075:15)[39m
[90m    at Module._load (node:internal/modules/cjs/loader:920:27)[39m
[90m    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)[39m
[90m    at node:internal/main/run_main_module:23:47[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: []
}

Node.js v18.14.2


判断文件是否读取成功
可以判断err对象是否为null，从而知晓文件读取的结果。

// 1．导入fs模块，来操作文件
const fs = require("fs")
// 2.调用fs.readFile()方法读取文件
fs.readFile('./test/readFiles.txt', 'utf8', function(err, result){
    if (err){
        console.log('文件读取失败~' + err.message)
        return 
    }
    console.log('文件读取成功，内容是：' + result)
})


** 向指定的文件中写入文件内容

fs.writeFile()的语法格式
使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下：

fs.writeFile(file, data[, options], callback)

file∶必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。

data：必选参数，表示要写入的内容。

options：可选参数，表示以什么格式写入文件内容，默认值是utf8。

callback：必选参数，文件写入完成后的回调函数。

// 1．导入fs文件系统模块
const fs = require("fs")
// 2.调用fs.writeFile()方法，写入文件内容
//     参数1:读取文件的存放路径
//     参数2:data：表示要写入的内容。
//     参数3:表示以什么格式写入文件内容，默认值是utf8。
//     参数4:文件写入完成后的回调函数。
fs.writeFile('./test/writeFile.txt', "HolleWorld", 'utf8', function(err){
    // 打印失败的结果
    console.log(err)
})


判断文件是否写入成功
可以判断err对象是否为null，从而知晓文件写入的结果。（当要写入的文件的文件夹盘符不存在，比如z盘那就会报错。

const fs = require("fs")
fs.writeFile('x/test/writeFile.txt', "HolleWorld", 'utf8', function(err){
    if(err){
        console.log('文件写入失败！' + err.message)
        return
    }
    console.log('文件写入成功')
})


** fs模块-路径动态拼接问题
相对路径
在使用 fs 模块操作文件时，如果提供的操作路径是以/或…/开头的相对路径时，很容易出现路径动态拼接错误的问题。
原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径。

最终呈现的路径就是执行node命令时的目录+代码中写的路径，所以在不同路径下执行js文件效果都不一样

绝对路径
移植性差

解决办法
__dirname：表示当前js文件所处的目录

console.log('__dirname', __dirname) 结果： __dirname D:\nodejs



* path模块处理路径

** 什么是path路径模块
path模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。

例如:

path.join()方法，用来将多个路径片段拼接成一个完整的路径字符串

path.basename()方法，用来从路径字符串中，将文件名解析出来

如果要在JavaScript 代码中，使用path模块来处理路径，则需要使用如下的方式先导入它：

const path = require('path')

** 路径拼接

1：path.join()的语法格式
使用path.join()方法，可以讲多个路径片段拼接为一个完整的路径字符串，语法格式如下：

path.join([...paths])

参数解读：

…paths 路径片段的序列

返回值 string


2：path.join()代码示例
注意在合成路径的时候，'…/'会抵消掉一层路径

const path = require('path')

const pathStr = path.join('/a', '/b/c', '../', './d', 'e')
console.log(pathStr)        \a\b\d\e，因为../的缘故，c被顶掉了

const pathStr2 = path.join(__dirname, './files/1212.txt')
console.log(pathStr2)       D:\nodejs\files\1212.txt


注意：今后凡是涉及到路径拼接的操作，都要使用path.join()方法进行处理。不要直接使用＋进行字符串的拼接。


** 获取路径中的文件名

path.basename()的语法格式
使用path.basename()方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下:

path.basename(path[, ext])

参数解读:

path ：必选参数，表示一个路径的字符串

ext ：可选参数，表示文件扩展名

返回值：表示路径中的最后一部分

const path = require('path')

const fpath = '/a/b/c/index.html'
var fullName = path.basename(fpath)
console.log(fullName)       index.html

var namewithoutExt = path.basename(fpath, ".html")
console.log(namewithoutExt)     index


** 获取路径中的文件扩展名

path.extname()的语法格式
使用path.extname()方法，可以获取路径中的扩展名部分，语法格式如下：

path.extname(path)

参数解读：

path：必选参数，表示一个路径的字符串

返回：返回得到的扩展名字符串

path.extname()代码示例
使用path.extname()方法，可以获取路径中的扩展名部分

（2）path.extname()代码示例
使用path.extname()方法，可以获取路径中的扩展名部分

const path = require('path')

const fpath = '/a/b/c/index.html'
const fext = path.extname(fpath)
console.log(fext)       .html


* 使用Http模块写一个Web服务器

** 什么是http模块

回顾:什么是客户端、什么是服务器?
在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务

http模块是Node,js官方提供的、用来创建web服务器的模块。通过 http模块提供的 http.createServer()方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。

如果要希望使用http模块创建Web服务器，则需要先导入它:

const http = require( 'http')

** 进一步理解http模块的作用

如何把一个普通电脑变成服务器
服务器和普通电脑的"区别"在于，服务器上安装了web服务器"软件"，例如:IlS、Apache等。通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器。

在Node.js中，我们不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于Node.提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web 服务。

** 服务器相关的概念
1：IP地址
IP地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方IP地址的前提下，才能与对应的电脑之间进行数据通信。

IP地址的格式:通常用“点分十进制”表示成(a.b.c.d)的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如：用点分十进表示的IP地址(192.168.1.1)

注意：
1.互联网中每台Web服务器，都有自己的IP地址
2.例如:大家可以在Windows 的终端中运行【ping www.baidu.com】命令，即可查看到百度服务器的IP地址。
3.在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当做一台服务器进行访问了。

注意:
单纯使用IP地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。
在开发测试期间，127.0.0.1对应的域名是localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。

端口号：大楼里面的小房间
计算机中的端口号，就好像是现实生活中的门牌号一样。通过"门牌号"，外卖小哥可以在整栋大楼(服务器)众多的房间中，准确把外卖送到你的手中。

同样的道理，在一台电脑中，可以运行成百上千个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的web服务进行处理。

注意:
1.每个端口号不能同时被多个web服务占用。一个小房间只能提供一种服务
2.在实际应用中，URL中的80端口可以被省略。

** 创建最基本的web服务器
创建Web服务器步骤
1.导入http模块
2.创建web 服务器实例
3.为服务器实例“绑定request事件”，监听客户端的请求
4.启动服务器

步骤一：导入http模块
如果希望在自己电脑上创建一个web服务器，从而对外提供web服务，则需要导入http模块。

const http = require('http')

步骤二：创建web服务器实例
调用 http.createServer()方法，即可快速创建一个Web服务器实例：

const server = http.createServer()

步骤三：为服务器实例绑定request事件
为服务器实例绑定request事件，即可监听客户端发送过来的网络请求:

// 使用服务器实例的.on()方法，为服务器绑定一个request事件
// 全局事件总线好像就是这个的灵感吧
server.on( 'request', (req,res) => {
    // 只要有客户端来请求我们自己的服务器，就会触发request 事件，从而调用这个事件处理函数
    console.log( 'Someone visit our web server.' )
})


步骤四：启动服务器
调用服务器实例的.listen()方法，即可启动当前的web 服务器实例:

// 调用server.listen(端口号，cb回调）方法，即可启动web 服务器
server.listen(80, () =>{
console.log('http server running at http://127.0.0.1')
})


创建Web服务器示例：

// 导入http模块
const http = require('http')
// 创建web 服务器实例
const server = http.createServer()
// 为服务器实例绑定request事件，监听客户端的请求
server.on( 'request', (req,res) => {
    // 只要有客户端来请求我们自己的服务器，就会触发request 事件，从而调用这个事件处理函数
    console.log( 'Someone visit our web server.' )
})

// 启动服务器
server.listen(8080, () =>{
    console.log('http server running at http://127.0.0.1:8080')
})

req请求对象

只要服务器接收到了客户端的请求，就会调用通过server.on()为服务器绑定的request事件处理函数。
如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式:

server.on( 'request', (req) =>{
    // req是请求对象，它包含了与客户端相关的数据和属性，例如:3 ll req.url是客户端请求的URL地址
    // req.method是客户端的 method请求类型
    const str = `Your request url is ${req.url}，and request method is ${req.method}`
    console.log(str)
})

完整代码：

const http = require('http')
const server = http.createServer()

server.on( 'request', (req) =>{
    // req是请求对象，它包含了与客户端相关的数据和属性，例如:3 ll req.url是客户端请求的URL地址
    // req.method是客户端的 method请求类型
    const str = `Your request url is ${req.url}，and request method is ${req.method}`
    console.log(str)
})

server.listen(8080, () =>{
    console.log('http server running at http://127.0.0.1:8080')
})


res响应对象

在服务器的request事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式:

server.on( 'request ', (req, res) => {
    // res是响应对象，它包含了与服务器相关的数据和属性，例如:31/要发送到客户端的字符串
    const str = `Your request url is ${req.url}，and request method is ${req.method}`
    // res.end()方法的作用:
    // 向客户端发送指定的内容，并结束这次请求的处理过程
    res.end(str)
})


完整代码：

const http = require('http')
const server = http.createServer()

server.on( 'request', (req, res) =>{
    // req.method是客户端的 method请求类型
    const str = `Your request url is ${req.url}，and request method is ${req.method}`
    console.log(str)
    // 调用 res.end()方法，向客户端响应一些内容
    res.end(str)
})

server.listen(8080, () =>{
    console.log('http server running at http://127.0.0.1:8080')
})


解决中文乱码问题
当调用res.end()方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式:

server.on('request', (req,res) => {
    //发送的内容包含中文
    const str =`您请求的url地址是${req.url}，请求的 method类型是${req.method}`
    // 为了防止中文显示乱码的问题，需要设置响应头Content-Type 的值为 text/html; charset=utf-8
    res.setHeader( 'Content-Type',  'text/html; charset=utf-8')
    // 把包含中文的内容，响应给客户端
    res.end(str)
})



const http = require('http')
const server = http.createServer()
server.on('request', (req,res) => {
    //发送的内容包含中文
    const str =`您请求的url地址是${req.url}，请求的 method类型是${req.method}`
    // 为了防止中文显示乱码的问题，需要设置响应头Content-Type 的值为 text/html; charset=utf-8
    res.setHeader( 'Content-Type',  'text/html; charset=utf-8')
    // 把包含中文的内容，响应给客户端
    res.end(str)
})
server.listen(8080, () =>{
    console.log('http server running at http://127.0.0.1:8080')
})


4.5：根据不同的url响应不同的html内容
（1）核心实现步骤：
①：获取请求的url地址

②：设置"默认"的响应内容为404 Not found

③：判断"用户请求"的是否为 / 或 /index.html 首页

④：判断用户请求的"是否为" /about.html 关于页面

⑤：设置 Content-Type 响应头，防止中文乱码

⑥：使用 res.end() 把内容响应给客户端


实现Web服务器就是把文件的实际存放路径，作为每个资源的url请求（服务器充当的角色就是一个字符串的搬运工）


* 模块化

** 模块化的基本概念
*** 什么是模块化
模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。

*** 编程领域中的模块化
编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个"小模块"。

把代码进行模块化拆分的好处:

1.提高了代码的复用性
2.提高了代码的可维护性
3.可以实现"按需加载"


** Node.js中的模块化
Node.js中模块的分类
Node.js中根据模块来源的不同，将模块分为了3大类，分别是:

内置模块（内置模块是由Node.js 官方提供的，例如fs、path、http等）
自定义模块（用户创建的每个.js文件，都是自定义模块）
第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）


- 加载模块
使用强大的require()方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如:

// 1．加载内置的fs模块
const fs = require('fs')

// 2．加载用户的自定义模块
const custom = require('./custom.js')

// 3．加载第三方模块
const moment = require( 'moment' )


注意：使用require()方法加载其它模块时，会"执行被加载模块"中的代码。

在使用require()"加载用户自定义模块"期间，可以省略.js后缀名


- Node.js中的模块作用域
什么是模块作用域
和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在"当前模块"内被访问，这种"模块级别的访问限制"，叫做模块作用域。

模块作用域的好处
防止了"全局变量污染"的问题


- 向外共享模块作用域中的成员
1）module 对象
在每个.js 自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息，可以打印出来看一下。

Module {
  id: '.',
  path: 'D:\\nodejs\\js\\test',
  exports: {},
  filename: 'D:\\nodejs\\js\\test\\1.js',
  loaded: false,
  children: [],
  paths: [
    'D:\\nodejs\\js\\test\\node_modules',
    'D:\\nodejs\\js\\node_modules',
    'D:\\nodejs\\node_modules',
    'D:\\node_modules'
  ]
}


这里面的exports: {},就是模块作用域中的成员

2）module.exports对象
在自定义模块中，可以使用module.exports对象，将模块内的成员"共享"出去，供外界使用。

外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所"指向的对象"，当然自定义模块还是会执行一次

(在一个自定义模块中，默认情况下，module.exports = {}， 是一个"空对象"）。

操作演示：

创建一个自定义模块名为【自定义模块.js】


3）共享成员时的注意点
使用require()方法导入模块时，最终，向外共享的结果，"永远"以 module.exports 指向的对象为准。

例如以下让module.exports指向一个全新的对象。

修改以下自定义模块.js的代码

// 在一个自定义模块中，默认情况下，module.exports = {} 
const age = 20

// 向 module.exports 对象上挂载 username 属性
module.exports.username = "hqh"
// 向 module.exports 对象上挂载 sayHello 方法
module.exports.sayHello = function(){
    console.log('Hello')
}
module.exports.age = age
// 让module.exports指向一个全新的对象，原本的对象就被覆盖了
// 以最后这个为准
module.exports = {
    nickname: "黄",
    sayLove(){
        console.log("I Love You!!")
    }
}



4）exports对象
由于module.exports 单词写起来比较复杂，为了"简化"向外共享成员的代码，Node提供了 exports 对象。"默认情况下"，exports和module.exports 指向同一个对象。"最终共享的结果"，还是以module.exports 指向的对象为准。

const age = 20

exports.username = "hqh"
exports.sayHello = function(){
    console.log('Hello')
}
exports.age = age
// 最终，向外共享的结果，永远以module.exports指向的对象为准。


5）exports和module.exports 的使用误区
时刻谨记!!! require()模块时，得到的永远是 module.exports 指向的对象；

为了防止混乱，建议不要再同一个模块中同时使用 exports 和 module.exports；


6）Node.js中的CommomJS模块化规范

Node.js 遵循了CommonJS"模块化规范"，CommonJS规定了模块的特性和各模块之间如何相互依赖。

CommonJS"规定":

每个模块内部,module变量代表"当前模块"。
module变量是一个"对象"，它的exports属性(即 module.exports）是"对外的接口"。
加载某个模块，其实是"加载该模块的module.exports属性"。require()方法用于"加载模块"。


** npm与包

*** 包

1）什么是包
Node.js 中的"第三方模块"又叫做包。

就像"电脑和计算机"指的是"相同"的东西，"第三方模块"和"包"指的是"同一个概念"，只不过叫法不同。

2）包的来源
不同于Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。

3）为什么需要包
由于Node.js 的内置模块"仅提供了一些底层的API"，导致在基于内置模块进行项目开发的时，"效率很低"。

包是"基于内置模块封装"出来的，提供了"更高级、更方便"的API，极大的提高了开发效率。

"包和内置模块之间的关系"，类似于jQuery和浏览器内置API之间的关系。


*** npm格式化时间

1）传统格式化时间的做法
1.创建格式化时间的自定义模块
2.定义格式化时间的方法
3.创建补零函数
4.从自定义模块中导出格式化时间的函数
5.导入格式化时间的自定义模块
6.调用格式化时间的函数


2）格式化时间的高级做法（npm）
使用npm包管理工具，在项目中安装格式化时间的包 moment
使用require()导入格式化时间的包
参考moment的官方API文档对时间进行格式化
先新建终端

npm install moment

// 1. 使用npm包管理工具，在项目中安装格式化时间的包 moment,使用require()导入格式化时间的包
const moment = require('moment')
// 2．参考moment官方API文档，调用对应的方法，对时间进行格式化
//     2.1调用moment()方法，得到当前的时问
//     2.2针对当前的时间，调用format()方法，按照指定的格式进行时间的格式化
const dt = moment().format('YYYY-MM-DD HH:mm:ss')
console.log(dt)

一个包怎么使用可以查看对应的npm官方文档

https://www.npmjs.com/


** 模块的加载机制

（1）"内置模块"的加载机制
内置模块是由Node.js 官方提供的模块，内置模块的加载"优先级最高"。
例如，require('fs')"始终"返回内置的fs模块，即使在node_modules目录下有名字相同的包也叫做fs。


（2）"自定义模块"的加载机制
使用require()加载自定义模块时，必须指定以/或…/开头的路径标识符。在加载自定义模块时，如果没有指定/或…这样的路径标识符，则node 会把它当作内置模块或第三方模块进行加载。

同时，在使用require()导入自定义模块时，如果"省略"了文件的扩展名，则Node.js 会按"顺序"分别尝试加载以下的文件:

1.按照确切的文件名进行加载
2.补全.js扩展名进行加载
3.补全.json扩展名进行加载
4.补全.node扩展名进行加载
5.加载失败，终端报错


（3）第三方模块的加载机制
如果传递给 require() 的模块标识符"不是一个内置模块"，也"没有"以‘”或‘.”’开头，则Node.js 会从当前模块的"父目录开始"，尝试从/node_modules文件夹中加载第三方模块。

如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。
例如，假设在’C:\Users\itheimaproject\tools’文件里调用了 require('tools')，则 Node.js 会按以下顺序查找:

C:\Users\itheimaproject\node_modules\tools
C:\Users\node_modules\tools
C:\node_modules\tools


（4）目录作为模块
当把目录作为模块标识符，传递给require()进行加载的时候，有三种加载方式:
1.在被加载的目录下查找一个叫做"package.json"的文件，并寻找 "main" 属性，作为require()加载的入口
2.如果目录里没有package.json文件，或者main入口不存在或无法解析，则 Node.js将会试图加载目录下的index.js文件。
3.如果以上两步都失败了，则Node.js 会在终端打印错误消息，报告模块的缺失:Eror. Cannot find module ‘kso’


* express

** 初识Express

- Express概述

1）什么是 Express
官方给出的概念：Express是基于Node.js平台，快速、开放、极简的Web开发框架。

通俗的理解：Express的作用和Node.js 内置的 http模块类似，是专门用来创建Web服务器的。

Express的本质：就是一个npm上的"第三方包"，提供了快速创建Web服务器的便捷方法。

Express的中文官网: http://www.expressjs.com.cn/

2）进一步理解Express
不使用Express也可以使用Node.Js提供的原生http模块。

但是http 内置模块用起来很"复杂"，"开发效率低"。Express是基于内置的 http模块进一步封装出来的，能够极大的提高开发效率。Express是"基于" http 内置模块进一步封装出来的。

3）Express能做什么呢
对于"前端"程序员来说，最常见的"两种"服务器，分别是:

Web 网站服务器：专门对外提供 Web 网页资源的服务器。

API 接口服务器：专门对外提供API接口的服务器。

使用Express我们可以方便、快速的创建Web 网站的服务器或API接口的服务器。

- Express的基本使用

1）安装Express

npm i express@4.17.1

2）创建基本的Web服务器
// 1．导入express
const express = require('express')
// 2．创建web服务器
const app = express()
// 3．调用app.listen(端口号，启动成功后的回调函数)，启动服务果
app.listen(80, () => {
    console.log( 'express server running at http://127.0.0.1')
})


3）监听GET请求
通过app.get()方法，可以监听客户端的GET请求，具体的语法格式如下：

// 参数1：客户端请求的URL地址
// 参数2：请求对应的处理函数
//        req：请求对象(包含了与请求相关的属性与方法)
//        res：响应对象（包含了与响应相关的属性与方法)
app.get( '请求URL', function(req,res) {/*处理函数*/})

4）监听post请求
通过app.post()方法，可以监听客户端的GET请求，具体的语法格式如下：
// 参数1：客户端请求的URL地址
// 参数2：请求对应的处理函数
//        req：请求对象(包含了与请求相关的属性与方法)
//        res：响应对象（包含了与响应相关的属性与方法)
app.post( '请求URL', function(req,res) {/*处理函数*/})

5）把内容响应给客户端
通过res.send(方法，可以把处理好的内容，发送给客户端：

app.get('/user', (req, res) =>{
    // 向客户端发送JSON对象
    res.send({ name:'zs', age: 20, gender: '男'})
})

app.post('/user', (req,res) =>{
    // 向客户端发送文本内容
    res.send('请求成功')
})



// 1．导入express
const express = require('express')
// 2．创建web服务器
const app = express()

// 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容
app.get('/user', (req, res) =>{
    // 调用express提供的res.sent()方法，向客户端发送JSON对象
    res.send({ name:'zs', age: 20, gender: '男'})
})
app.post( '/user', (req,res) =>{
    // 调用express提供的res.send()方法，向客户端发送文本内容
    res.send('请求成功')
})

// 3．调用app.listen(端口号，启动成功后的回调函数)，启动服务果
app.listen(80, () => {
    console.log( 'express server running at http://127.0.0.1')
})


6）获取 URL 中携带的查询参数
通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：

app.get( ' /', (req, res) => {
    // req.query 默认是一个空对象
    // 客户端使用?name=zs&age=20这种查询字符串形式，发送到服务器的参数
    // 可以通过req.query 对象访问到，例如:
    // req.query.name    req.query.age
    console.log(req.query)
})


// 1．导入express
const express = require('express')
// 2．创建web服务器
const app = express()

// 通过req.query对象，可以访问到客户端发送过来的查询参数
// 注意默认情况下，req.query是一个空对象
app.get( '/', (req, res) => {
    console.log(req.query)
    res.send(req.query)
})

// 3．调用app.listen(端口号，启动成功后的回调函数)，启动服务果
app.listen(80, () => {
    console.log( 'express server running at http://127.0.0.1')
})


7）获取URL中的动态参数
通过req.params对象，可以访问到URL中，通过**:符号匹配到的动态参数**：
// URL地址中，可以通过:参数名的形式，匹配动态参数值
app.get( '/user/:id', (req, res) => {
    // req.params默认是一个空对象
    //里面存放着通过:动态匹配到的参数值
    console.log(req.params)
})



const express = require('express')
const app = express()
// 这里的:id是一个动态参数
app.get( '/user/:id', (req, res) => {
    // req.params是动态匹配到的URL参数，默认也是一个空对象
    console.log(req.params)
    res.send(req.params)
})
app.listen(80, () => {
    console.log( 'express server running at http://127.0.0.1')
})

使用详情：

参数里面的内容是前端发过来的路由里面填写的，参数名是代码里面的路由填写的。

而且:后面的字符串是自己取的，且可以有多个动态参数


- express托管静态资源

1）express.static()
express 提供了一个非常好用的函数，叫做express.static)，通过它，我们可以非常方便地创建一个"静态资源服务器",例如，通过如下代码就可以将public目录下的图片、CSS文件、JavaScript文件"对外开放访问了"：

app.use(express.static('public'))

现在，你就可以访问public目录中的所有文件了：

1.http://localhost:3000/images/bg.jpg
2.http://localhost:3000/css/style.css
3.http://localhost:3000/js/login.js

注意：Express在指定的静态目录中查找文件，并"对外提供"资源的"访问路径"。因此，存放静态文件的"目录名不会"出现在URL中。

const express = require('express')
const app =express()
// 在这里，调用express.static()方法对外界提供静态资源
app.use(express.static('./静态资源文件夹'))

app.listen(80, ()=>{
    console.log( 'express server running at http://127.0.0.1')
})

2）托管多个静态资源的目录
如果要托管多个静态资源目录，请多次调用express.static()函数：

app.use( express.static('public'))
app.use( express.static('files'))

访问静态资源文件时，express.static函数会根据目录的添加"顺序查找"所需的文件。

3）挂载路径前缀  有问题
如果希望在托管的静态资源访问路径之前，"挂载"路径前缀，则可以使用如下的方式：
app.use('./abcs', express.static('public'))

现在，你就可以通过带有/abcs前缀地址来访问public目录中的文件了：

http://localhost:3000/abcs/images/kitten.jpg
http://localhost:3000/abcs/css/style.css
http://localhost:3000/abcs/app.js



（4）nodemon
1）为什么要使用nodemon
在编写调试Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动close掉，然后再重新启动，非常繁琐。

现在，我们可以使用nodemon (https://www.npmjs.com/package/nodemon) 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。

2）安装nodemon
npm install -g nodemon

3）使用nodemon
当基于Nodejs编写了一个网站应用的时候，传统的方式，是运行node app.js 命令，来启动项目。这样做的坏处是:代码被修改之后，需要手动重启项目。

现在，我们可以将node命令替换为nodemon命令，使用nodemon app.js 来启动项目。这样做的好处是：代码被修改之后，会被nodemon监听到，从而实现自动重启项目的效果。

只要代码更改并且Ctrl+S，就会自动重启


** Express"路由"

*** Express的"路由"

1）Express的路由

在Express中，路由指的是客户端的"请求"与服务器"处理函数"之间的映射关系。

Express 中的"路由"分3部分组成，分别是请求的"类型"、请求的"URL"地址、"处理函数"，格式如下：

app.METHOD(PATH, HANDLER)

METHOD：请求类型，值可以使GET也可以是POST

PATH：请求的URL地址

HANDLER：服务器端的处理函数


2）Express中路由的例子

// 匹配GET请求，且请求 URL为/
app.get( '/', function (req,res) {
    res.send( 'Hello world! ')
})
// 匹配POST请求，且请求URL为/
app.post( '/', function (req,res){
    res.send('Got a POST request')
})


3）路由的匹配过程
每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。

在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则 Express 会将这次请求，转交给对应的function函数进行处理。

路由匹配的注意点:

1.按照定义的"先后顺序"进行匹配
2.请求类型和请求的URL"同时匹配成功"，才会调用对应的处理函数


- 路由的使用

1）最简单的用法
在Express中使用路由最简单的方式，就是把“路由挂载”到 app 上，示例代码如下：

const express = require( 'express')    //创建web服务器，命名为app
const app = express()
// 挂载路由
app.get( '/', (req,res)=> { res.send( 'Hello world.')})
app.post( '/', (req,res) => { res.send( 'Post Request.')})
// 启动web服务器
app.listen(80, () => { console.log( 'server running at http://127.0.0.1')})


- 模块化路由
1）模块化路由
为了方便对路由进行模块化的管理，Express "不建议"将路由直接挂载到app 上，而是推荐将路由"抽离为单独的模块"。

将路由抽离为单独模块的步骤如下:

1.创建路由模块对应的.js文件
2.调用express.Router()函数创建路由对象
3.向路由对象上挂载具体的路由
4.使用module.exports向外共享路由对象
5.使用app.use()函数"注册"路由模块


2）创建路由模块
var express = require( 'express ')
// 1．导入express
var router = express.Router()
// 2．创建路由对象
router.get( '/user/list',function(req,res) {               //3．挂载获取用户列表的路由
    res.send( 'Get user list.')
})
router.post( '/user/add', function(req,res) {             // 4．挂载添加用户的路由
    res.send('Add new user.')
})
module.exports = router                                    // 5．向外导出路由对象


router.js

// 这是路由导入模块
// 1.导入 express
const express = require('express')
// 2.创建路由对象
const router = express.Router()

// 3.挂在具体路由
router.get( '/user/list',function(req,res) {
    res.send( 'Get user list.')
})
router.post( '/user/add', function(req,res) {
    res.send('Add new user.')
})
// 4.向外到处路由对象
module.exports = router


模块化路由.js

var express = require( 'express')
const app = express()

// 1.导入路由模块
const router = require('./router')
// 2.注册路由模块
// 注意：app.use()函数的作用，就是用来"注册全局中间件"
app.use(router)

app.listen(80, () => {
    console.log( 'server running at http://127.0.0.1')
})

（4）为路由模块添加前缀
类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：

// 1．导入路由模块
const userRouter = require( './router/user.js')
// 2．使用app.use()注册路由模块，并添加统一的访问前缀/api
app.use( '/api ', userRouter)


** Express 中间件

- 中间件的概念
1）什么是中间件
特指业务处理过程中的"中间处理环节"

2）中间件的概念
中间件指的就是业务处理过程中的中间处理过程，并且中间件必须有"输入和输出"，上一级的输出就是下一级中间件的输入。

3）Express中间件的"调用流程"
当一个请求到达Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行"预处理"。

4）Express 中间件的格式
Express的中间件，本质上就是一个function处理函数，Express中间件的格式如下：


** Express 中间件的使用

1）定义中间件函数
可以通过如下方式，定义一个最简单的中间件函数：

// 常量mw所指向的，就是一个中间件函数
const mw = function (req, res，next){
    console.log( '这是一个最简单的中间件函数')
    // 注意:在当前中间件的业务处理完毕后，"必须"调用next()函数
    // 表示把流转关系转交给下一个中间件或路由
    next()
} 


定义一个最简单的中间件函数示例：

const express = require('express')
const app = express()

// 定义一个最简单的中间件函数
const mw = function(req, res, next){
    console.log("这是最简单的中间件函数")
    // 把流转关系，转交给下一个中间件或路由
    next()
}

// 启动web服务器
app.listen(80, () => {
    console.log('server running at http://127.0.0.1')
})


2）"全局"生效的中间件
客户端发起的"任何请求"，到达服务器之后，都会触发的中间件，叫做"全局生效"的中间件。
通过调用app.use(中间件函数)，即可定义一个全局生效的中间件，示例代码如下：

// 常量mw所指向的，就是一个中间件函数
const mw = function (req, res，next){
    console.log( '这是一个最简单的中间件函数')
    next()
}
// 将 mw 注册为全局生效的中间件
app.use(mw)

只要有一个请求到达了我们的服务器，必然会经过mw函数的处理，处理完之后就会调用next函数把结果交给之后的"中间件或路由"。

全局中间件示例：

const express = require( 'express')
const app = express()

// 定义一个最简单的中间件函数
const mw = function(req, res, next){
    console.log("这是最简单的中间件函数")
    // 把流转关系，转交给下一个中间件或路由
    next()
}

// 将 mw 注册为全局生效的中间件
app.use(mw)

app.get('/', (req,res)=> {
    res.send( 'Hello world.')
})
app.post('/', (req,res) => { 
    res.send( 'Post Request.')
})

// 启动web服务器
app.listen(80, () => {
    console.log('server running at http://127.0.0.1')
})


3）定义全局中间件的"简化形式"
// 全局生效的中间件
app.use(function (req, res，next){
    console.log( '这是一个最简单的中间件函数')
    next()
})

路由和中间件一起用就不打印了，很神奇？


3）定义全局中间件的简化形式
// 全局生效的中间件
app.use(function (req, res，next){
    console.log( '这是一个最简单的中间件函数')
    next()
})


4）中间件的作用

多个中间件之间，"共享"同一份req和res。基于这样的特性，我们可以在"上游"的中间件中，统一为req或res对象添加"自定义的属性或方法"，供下游的中间件或路由进行使用.

const express = require( 'express')
const app = express()

app.use(function(req, res, next){
    // 获取到请求到达服务器的时间
    const time = Date.now()
    // 为req对象，挂载自定义属性，从而把时间共享给后面的路由
    req.startTime = time
    next()
})

app.get('/', (req,res)=> {
    res.send( 'Hello world.' + req.startTime)
})
app.post('/', (req,res) => { 
    res.send( 'Post Request.' + req.startTime)
})

// 启动web服务器
app.listen(80, () => {
    console.log('server running at http://127.0.0.1')
})


5）定义多个全局中间件
可以使用app.use()连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用，示例代码如下：

app.use(function(req, res, next){            // 第一个全局中间件
    console.log("调用第一个全局中间件")
    next()
})
app.use(function(req, res, next){            // 第二个全局中间件
    console.log("调用第二个全局中间件")
    next()
})
app.get('/', (req,res)=> {           // 请求这个路由，会依次触发上面两个全局中间件
    res.send( 'Hello world.')
})


6）局部生效的中间件
不使用app.use()定义的中间件，叫做局部生效的中间件，示例代码如下:

// 定义中间件
const mw = function (req, res，next){
    console.log( '这是中间件函数')
    next()
}
// mw1这个中间件只在"当前路由中生效"，这种用法属于"局部生效的中间件"
app.get('/' , mw，function(req,res){
    res.send('Home page.')
})
// mw1这个中间件不会影响下面这个路由↓↓↓
app.get( '/user', function(req,res) {res.send( 'User page.'))


7）定义多个局部中间件
可以在路由中，通过如下两种等价的方式，使用多个局部中间件：

// 以下两种写法是"完全等价"的，可根据自己的喜好，选择任意一种方式进行使用
app.get( '/', mw1，mw2，(req，res) => { res.send('Home page.') })
app.get( '/'，[mw1, nw2]，(req，res) => { res.send('Home page.') })


8）了接中间件的5个使用注意事项
1.“一定要在路由之前注册中间件”
2.客户端发送过来的请求，可以"连续"调用"多个"中间件进行处理
3.执行完中间件的业务代码之后，"不要忘记"调用next()函数
4.为了防止代码逻辑混乱，调用next()函数后"不要再写额外的代码"
5.连续调用多个中间件时，多个中间件之间，"共享"req和res对象


- 中间件的分类
为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了5大类，分别是：

1.应用级别的中间件
2.路由级别的中间件
3.错误级别的中间件
4.Express内置的中间件
5.第三方的中间件


1）应用级别的中间件
通过app.use()或app.get()或 app.post()，绑定到app实例上的中间件，叫做应用级别的中间件，（就是最终被绑定到get和post请求上的中间件）代码示例如下:

// 应用级别的中间件（全局中间件）
app.use(function (req, res，next){
    next()
})
// 应用级别的中间件（局部中间件）
app.get('/' , mw1，function(req,res){
    res.send('Home page.')
})


2）路由级别的中间件
绑定到 express.Router() 实例上的"中间件"，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到router实例上，代码示例如下：

var app = express()
var router = express.Router()
// 路由级别的中间件
router.use(function (req,res，next) {
    console.log('Time: ' ,Date.now())
    next()
})
app.use( '/',router)


3）错误级别的中间件
错误级别中间件的作用:专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。
格式∶错误级别中间件的 function处理函数中，必须有"4个形参"，形参顺序从前到后，分别是(err, req, res, next)。
还是用过app.use()注册一个全局中间件，但是多一个参数err。

app.get( '/' , function (req, res){            // 1．路由
    throw new Error('服务器内部发生了错误! ')    // 1.1抛出一个自定义的错误
    res.send('Home Page.')
})

app.use(function(err, req, res, next) {         // 2．错误级别的中间件
    console.log('发生了错误:' + err.message)     // 2.1在服务器打印错误消息
    res.send( 'Error! ' + err.message)        // 2.2向客户端响应错误相关的内容
})


注意:"错误”级别的中间件，必须注册在所有路由“之后”！！！！！！！！！！


4）Express“内置”的中间件
自Express 4.16.0 版本开始，Express 内置了3个常用的中间件，极大的提高了Express项目的开发效率和体验：

1.express.static 快速托管静态资源的内置中间件，例如:HTML文件、图片、CSS样式等（无兼容性)
2.express.json 解析JSON格式的"请求体数据"（有兼容性，仅在4.16.0+版本中可用)
3.express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在4.16.0+版本中可用)

// 配置解析 application/json 格式数据的内置中间件
app.use(express.json())
// 配置解析 application/x-ww-form-urlencoded 格式数据的内置中间件
app.use(express.urlencoded({ extended: false }))


5）第三方的中间件
非Express官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。

例如:在express@4.16.0之前的版本中，经常使用body-parser这个第三方中间件，来解析请求体数据。使用步骤如下:

1.运行npm install body-parser安装中间件
2.使用require 导入中间件
3.调用app.use()注册并使用中间件

注意:Express 内置的express.urlencoded 中间件，就是基于body-parser这个第三方中间件进一步封装出来的。


- 自定义中间件

1）需求描述与实现步骤

自己手动模拟一个类似于express.urlencoded 这样的中间件，来解析 POST 提交到服务器的"表单"数据。

实现步骤：

1.定义中间件
2."监听"req的data事件（只要触发了req的data事件就说明有数据被提交过来了）
3."监听"req的end事件（只要触发了req的data事件就说明数据已经发送完毕了，在服务端已经收到了post发送的数据了，只不过这个数据还需要做进一步的处理）
4.使用 querystring 模块"解析"请求体数据
5.将解析出来的数据对象"挂载"为req.body
6.将自定义中间件"封装为模块"

2）定义中间件
使用app.use()定义全局中间件，然后在中间件里面写业务逻辑

const express = require( 'express')
const app = express()

// 这是解析表单数据的中间件
app.use((req, res, next)=>{
    // 定义中间件具体的业务逻辑
})
// 启动web服务器
app.listen(80, () => {
    console.log('server running at http://127.0.0.1')
})


3）监听 req 的 data 事件
在中间件中，需要监听req对象的data事件，来获取客户端发送到服务器的数据。

如果数据量比较大，无法一次性发送完毕，则客户端会把数据"切割"后，分批发送到服务器。所以data事件可能会"触发多次"，每一次触发data事件时，获取到数据只是完整数据的"一部分"，需要手动对接收到的数据进行"拼接"。

// 定义变量，用来"存储"客户端发送过来的请求体数据
let str = ''
// 监听req对象的 data 事件(客户端发送过来的新的请求体数据)
req.on('data' , (chunk) =>{
    //拼接请求体数据，隐式转换为字符串
    str += chunk
})


4）监听req的end事件
当请求体数据接收完毕之后，会自动触发req的end事件。

因此，我们可以在req的end事件中，拿到并处理完整的请求体数据。示例代码如下：

// 监听req对象的end事件(请求体发送完毕后自动触发)
req.on('end', ()=> {
    // 打印完整的请求体数据
    console.log(str)
    // TODO:把字符串格式的请求体数据，解析成对象格式
})

5）使用querystring 模块解析请求体数据
Node.js内置了一个querystring 模块，专门用来处理查询字符串。通过这个模块提供的parse()函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下:

// 导入处理querystring的 Node.js内置模块
const qs = require( 'querystring')
// 调用qs.parse()方法，把查询字符串解析为对象
const body = qs.parse(str)


6）将解析出来的数据对象挂载为req.body
上游的中间件和下游的中间件及路由之间，共享同一份req和res。因此，我们可以将解析出来的数据，挂载为req的自定义属性，命名为req.body，供下游使用。示例代码如下：

req.on( 'end' , () =>{
    const body = qs.parse(str)    //调用qs.parse(）方法，把查询字符串解析为对象
    req.body = body                //将解析出来的请求体对象，挂载为req.body属性
    next()                        //最后，一定要调用next()函数，执行后续的业务逻辑
})

7）将自定义的中间件封装为模块
为了优化代码的结构，我们可以把自定义的中间件函数，封装为"独立的模块"，示例代码如下：

// custom-body-parser.js模块中的代码
const qs = require( 'querystring')
function bodyParser(req, res, next) {/*省略其它代码*/ }
module.exports = bodyParser                // 向外导出解析请求体数据的中间件函数

// ------------------------分割线---------------------------
// 1．导入自定义的中间件模块
const myBodyParser = require('custom-body-parser')
// 2．注册自定义的中间件模块
app.use(myBodyParser)

8）全部代码如下：
对自定义的中间件进行模块化的拆分.js

const express = require( 'express')
const app = express()

// 导入处理querystring的 Node.js内置模块
const qs = require('querystring')

// 1.导入自己封装的中间件模块
const customBodyParser = require('./11.custom-body-parser')
// 2．将自定义的中间件模块注册为全局可用的中间件
app.use(customBodyParser)

app.post('/user', (req, res) =>{
    res.send(req.body)
})

// 启动web服务器
app.listen(80, () => {
    console.log('server running at http://127.0.0.1')
})


11.custom-body-parser.js

// 导入处理querystring的 Node.js内置模块
const qs = require('querystring')

const bodyParser = (req, res, next)=>{
    // 定义中间件具体的业务逻辑
    // 1.定义一个str字符串，专门用来存储客户端发送过来的请求体数据
    let str = ''
    // 2.监听 data 事件
    req.on('data' , (chunk) =>{
        str += chunk
    })
    // 监听req的end事件
    req.on('end', ()=> {
        // 在str中存放的就是完整的请求体数据
        console.log(str)
        // TODO:把字符串格式的请求体数据，解析成对象格式
        const body = qs.parse(str)
        req.body = body                //将解析出来的请求体对象，挂载为req.body属性
        next()
    })
}
module.exports = bodyParser


** Express写接口

- 创建一个最基本的服务器

// 导入express模块
const express = require('express')
//创建express的服务器实例
const app = express()

// write your code here.. .

//调用app.listen方法，指定端口号并启动web服务器
app.listen(80, function () {
    console.log('Express server running at http://127.0.0.1')
})

（2）创建API路由模块

const express = require('express')
const apiRouter = express.Router()

// bind your router here.

module.exports = apiRouter
// ------------------------分割线---------------------------

// app.js 【导入并注册路由模块】
const apiRouter = require( './13.apiRouter')
app.use( '/api' , apiRouter)


（3）编写GET接口
apiRouter.get( '/get', (req,res) =>{
    // 1．获取到客户端通过查询字符串，发送到服务器的数据
    const query = req.query
    // 2．调用res.send()方法，把数据响应给客户端
    res.send({
        status: 0,                    // 状态，О表示成功，1表示失败
        msg: 'GET请求成功!',          //状态描述
        data: query                    //需要响应给客户端的具体数据
    })
})


（4）编写POST接口
// 配置解析表单数据中间件
app.use(express.urlencoded({ extended:false }))
// ------------------------分割线---------------------------
apiRouter.post( '/post', (req,res) =>{
    // 1．获取到客户端通过查询字符串，发送到服务器的 URL-encoded 数据
    const body = req.body
    // 2．调用res.send()方法，把数据响应给客户端
    res.send({
        status: 0,                    // 状态，О表示成功，1表示失败
        msg: 'POST请求成功!',          //状态描述
        data: body                    //需要响应给客户端的具体数据
    })
})


（5）CORS跨域资源共享
1）"接口"的跨域问题
刚才编写的"GET和POST接口"，存在一个很严重的问题："不支持跨域请求"。

解决接口跨域问题的方案主要有两种:

CORS（主流的解决方案，推荐使用）
JSONP（有缺陷的解决方案:只支持GET请求）

2）使用CORS中间件解决跨域问题
cors 是Express的一个第三方中间件。通过安装和配置cors 中间件，可以很方便地解决跨域问题。使用步骤分为如下3步:

1.运行 npm install cors 安装中间件
2.使用 const cors = require(‘core’) 导入中间件
3.在路由之前调用 app.use(cors()) 配置中间件

3）什么是CORS
CORS（Cross-Origin Resource Sharing，跨域资源共享）由一系列HTTP响应头组成，这些"HTTP响应头"决定浏览器是否阻止前端JS代码跨域获取资源。

浏览器的"同源安全策略"默认会阻止网页"跨域"获取资源。但如果"接口服务器"配置了CORS相关的HTTP响应头，就可以解除浏览器端的跨域访问限制。

4）CORS 的注意事项
CORS主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了CORS的接口。

CORS在浏览器中有兼容性。只有支持XMLHttpRequest Level2的浏览器，才能正常访问开启了CORS的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。

5）CORS响应头部—— Access-Control-Allow-Origin
响应头部中可以携带一个 Access-Control-Allow-Origin字段，其语法如下：

Access-Control-Allow-Origin: <origin> | *

其中,origin参数的值指定了允许访问该资源的外域URL。

例如，下面的字段值将只允许来自 http://itcast.cn 的请求：

res.setHeader('Access-Control-Allow-Origin', 'http://itcast.cn')

如果指定了Access-Control-Allow-Origin 字段的值为通配符*，表示允许来自任何域的请求，示例代码如下：

res.setHeader('Access-Control-Allow-Origin', '*')

6）CORS响应头部——Access-Control-Allow-Headers
默认情况下，CORS仅支持客户端向服务器发送如下的9个请求头:

Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type(值仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一)

如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers对额外的请求头进行声明，否则这次请求会失败！

示例代码如下:

// 允许客户端额外向服务器发送Content-Type请求头和X-Custom-Header请求头
// 注意:多个请求头之间使用英文的逗号进行分割
res.setHeader('Access-Control-Allow-Headers','Content-Type,X-Custom-Header')


7）CORS 响应头部——Access-Control-Allow-Methods
默认情况下，CORS仅支持客户端发起GET、POST、HEAD请求。

如果客户端希望通过PUT、DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Alow-Methods来指明实际请求所允许使用的HTTP方法。

示例代码如下:

// 只允许POST、GET、DELETE、HEAD请求方法
res.setHeader( 'Access-Control-Allow-Methods', 'POST，GET，DELETE，HEAD')
// 允许所有的 HTTP请求方法
res.setHeader( 'Access-Control-Allow-Methods', '*')


8）CORS请求的分类
客户端在请求CORS接口时，根据请求方式和请求头的不同，可以将CORS的请求分为两大类，分别是:

1.简单请求
2.预检请求

9）简单请求
同时满足以下两大条件的请求，就属于简单请求:

请求方式：GET、POST、HEAD三者之一

HTTP头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）

10）预检请求
只要符合以下任何一个条件的请求，都需要进行预检请求：

1.请求方式为GET、POST、HEAD之外的请求
2.Method类型请求头中包含自定义头部字段
3.向服务器发送了 application/json 格式的数据

在浏览器与服务器正式通信之前，浏览器会先发送ОPTION请求进行预检，以获知服务器是否允许该实际请求，所以这一次的OPTION请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。

11）简单请求和预检请求的区别
简单请求的特点：客户端与服务器之间只会发生一次请求。

预检请求的特点：客户端与服务器之间会发生两次请求，OPTION预检请求成功之后，才会发起真正的请求。


（6）JSONP 接口

1）回顾JSONP的概念与特点
概念: 浏览器端"通过"

特点:

1.JSONP不属于真正的Ajax请求，因为它没有使用XMLHttpRequest这个对象。
2.JSONP仅支持GET请求，不支持POST、PUT、DELETE等请求。

2）创建JSONP 接口的注意事项
如果项目中已经配置了CORS跨域资源共享，为了防止冲突，必须在配置CORS中间件之前"声明"JSONP的接口。否则JSONP接口会被处理成开启了CORS的接口。示例代码如下：

顺序问题
// 优先创建JSONP接口【这个接口不会被处理成 CORS接口】
app.get( '/api/jsonp', (req,res) =>{ })

// 再配置 CORS中间件【后续的所有接口，都会被处理成CORS 接口】
app.use(cors())

// 这是一个开启了CORS的接口
app.get('/api/get', (req,res)=>{ })

3）实现JSONP接口的步骤
1.获取客户端发送过来的回调函数的名字
2.得到要通过JSONP形式发送给客户端的数据
3.根据前两步得到的数据，拼接出一个函数调用的字符串
4.把上一步拼接得到的字符串，响应给客户端的


4）实现JSONP接口的具体代码
app.get( '/api/jsonp', (req, res) => {
    // 1．获取客户端发送过来的回调函数的名字
    const funcName = req.query.callback
    // 2．得到要通过JSONP形式发送给客户端的数据
    const data = { name: 'zs', age: 22 }
    // 3．根据前两步得到的数据，拼接出一个函数调用的字符串
    const scriptStr = `${funcName}(${JSON.stringify(data)})`
    // 4．把上一步拼接得到的字符串，响应给客户端的<script>标签进行解析执行
    res.send(scriptstr)
})


* 数据库与身份认证

能够知道如何配置MySQL数据库环境

能够认识并使用常见的SQL语句操作数据库

能够在 Express 中操作MySQL数据库

能够了解 Session 的实现原理

能够了解JWT（Java Web Token）的实现原理


7.1：数据库的基本概念

（1）什么是数据库
数据库(database)是用来组织、存储和管理数据的仓库。

当今世界是一个充满着数据的互联网世界，充斥着大量的数据。数据的来源有很多，比如出行记录、消费记录：浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。

为了方便管理互联网世界中的数据，就有了数据库管理系统的概念(简称:数据库)。用户可以对数据库中的数据进行新增、查询、更新、删除等操作。

（2）常见的数据库及分类
1.MySQL数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise）
2.Oracle数据库（收费）
3.SQL Server数据库（收费）
4.Mongodb 数据库（Community + Enterprise）


查询用户密码

select host,user,authentication_string from mysql.user;


设置（或修改）root用户密码

use mysql
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '密码';

保存一下：

flush privileges;

退出

quit
Bye


** 在Express中操作MySQL

（1）在项目中操作数据库的步骤
1.安装操作MySQL数据库的第三方模块(mysql)
2.通过 mysql模块连接到MySQL 数据库
3.通过 mysql模块执行SQL语句

（2）安装与配置mysql模块
1）安装mysql模块
mysql模块是托管于npm 上的第三方模块。它提供了在Node.js项目中连接和操作MySQL数据库的能力。

想要在项目中使用它，需要先运行如下命令，将mysql安装为项目的依赖包:

2）配置mysql模块
在使用mysql模块操作MySQL数据库之前，必须先对 mysql模块进行必要的配置，主要的配置步骤如下：

// 1．导入mysql模块
const mysql = require( 'mysql')
// 2．建立与 MySQL 数据库的连接
const db = mysql.createPool({
    host: '127.0.0.1',        //数据库的IP地址
    user: 'root',            // 登录数据库的账号
    password: '528957',        // 登录数据库的密码
    database: 'my_db_01'    //指定要操作哪个数据库
})


3）测试mysql模块能否正常工作
调用db.query()函数，指定要执行的SQL语句，通过回调函数拿到执行的结果：

// 检测mysql模块能否正常工作
db.query( 'select 1', (err, results) => {
    if (err) return console.log(err.message)
    // 只要能打印出[ RowDataPacket { '1':1 }]的结果，就证明数据库连接正常
    console.log(results)
})


- 使用mysql模块操作MySQL数据库

1）查询语句
查询users表中所有的用户数据

// 查询users表中所有的用户数据
db.query( 'SELECT * FROM users', (err, results) =>{
    //查询失败
    if (err) return console.log(err.message)
    //查询成功
    console.log(results)
})


2）插入数据
向users表中新增一条数据，

其中，username是 Spider-Man，password是pcc123。示例代码如下：

// 1．要插入到users表中的数据对象
const user = {nikename:'Spider-Man', username: 'sm123456' , password: 'pcc321', states: 0}
//2．待执行的SQL语句，其中英文的?表示占位符
const sqlStr = 'INSERT INTO users (username, password, nikename, states) VALUES (?, ?, ?, ?)'
// 3．使用数组的形式，依次为?占位符指定具体的值
db.query(sqlStr, [user.username, user.password, user.nikename, user.states],(err, results) =>{
    if (err) return console.log(err.message)    //失败
    if(results.affectedRows === 1) {
        console.log('插入数据成功')
    }                                           //成功
})


3）插入数据的便携方式
向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：


// 1．要插入到users表中的数据对象
const user =  {nikename:'Spider-Man2', username: 'sm123456' , password: 'pcc321', states: 0}
// 2．待执行的SQL语句，其中英文的 ?表示占位符
const sqlstr = 'INSERT INTO users SET ?'
// 3．直接将数据对象当作占位符的值
db.query(sqlstr, user, (err, results) => {
    if (err) return console.log(err.message)                             //失败
    if(results.affectedRows === 1) i console.log('插入数据成功')}            //成功
})


4）更新数据
可以通过如下方式，更新表中的数据：

// 1．要更新的数据对象
const user = { id: 1, username: 'aaa', password: '000'}
// 2．要执行的SQL语句
const sqlStr = 'UPDATE users SET username=?, password=? WHERE id=?'
// 3．调用db.query()执行SQL语句的同时，使用数组依次为占位符指定具体的值
db.query(sqlStr, [user.username, user.password, user.id], (err, results)=>{
    if (err) return console.log(err.message)                        //失败
    if (results.affectedRows === 1) { console.log('更新数据成功!')}     //成功
})


5）更新数据的便携方式
更新表数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速更新表数据：


// 1．要更新的数据对象
const user = { id: 1, username: 'bbb', password: '111'}
// 2．要执行的SQL语句
const sqlStr = 'UPDATE users SET ? WHERE id=?'
// 3．调用db.query()执行SQL语句的同时，使用数组依次为占位符指定具体的值
db.query(sqlStr, [user, user.id], (err, results)=>{
    if (err) return console.log(err.message)                        //失败
    if (results.affectedRows === 1) { console.log('更新数据成功!')}     //成功
})


6）删除数据
在删除数据时，推荐根据id这样的唯一标识，来删除对应的数据。示例如下：


// 1．要执行的SQL语句
const sq1Str = 'DELETE FROM users wHERE id=?'
// 2，调用db.query(）执行SQL语句的同时，为占位符指定具体的值
// 注意:如果 SQL语句中有多个占位符，则必须使用数组为每个占位符指定具体的值
//         如果SQL语句中只有一个占位符，则可以省略数组
db.query(sq1Str，1，(err，results) =>{
    if (err) return console.log(err.message)                        //失败
    if (results.affectedRows == 1) { console.log('删除数据成功! ')}     //成功
})


7）标记删除
使用DELETE语句，会把真正的把数据从表中删除掉。为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。

所谓的标记删除，就是在表中设置类似于 status这样的状态字段，来标记当前这条数据是否被删除。

当用户执行了删除的动作时，我们并没有执行DELETE语句把数据删除掉，而是执行了UPDATE语句，将这条数据对应的status字段标记为删除即可。


// 标记删除:使用UPDATE语句替代 DELETE语句;只更新数据的状态，并没有真正删除
db.query( "UPDATE users SET status=1 WHERE id=?'，6，(err，results)=> {
    if (err) return console.log(err.message)                        //失败
    if (results.affectedRows === 1) { console.log('删除数据成功! ')}     //成功
})


** 前后端的身份认证

- 身份认证
1）什么是身份认证
身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。

日常生活中的身份认证随处可见，例如：高铁的验票乘车，手机的密码或指纹解锁，支付宝或微信的支付密码等。

在Web开发中，也涉及到用户身份的认证，例如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等。

2）为什么需要身份认证
身份认证的目的，是为了确认当前所声称为某种身份的用户，确实是所声称的用户。例如你去找快递员取快递，你要怎么证明这份快递是你的。

在互联网项目开发中，如何对用户的身份进行认证，是一个值得深入探讨的问题。例如，如何才能保证网站不会错误的将“马云的存款数额”显示到“马化腾的账户”上。

3）不同开发模式下的身份认证
对于"服务端渲染"和"前后端分离"这两种开发模式来说，分别有着不同的身份认证方案:

1."服务端渲染"推荐使用 Session 认证机制
2.前后端分离推荐使用 JWT 认证机制


- Session认证机制

1）HTTP协议的"无状态性"

了解HTTP协议的无状态性是进一步学习Session认证机制的必要前提。

HTTP协议的无状态性，指的是客户端的每次HTTP请求都是"独立"的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态。

2）如何突破HTTP无状态的限制
对于超市来说，为了方便收银员在进行结算时给VIP用户打折，超市可以为每个VIP用户发放会员卡。

现实生活中的"会员卡"身份认证方式，在Web开发中的专业术语叫做"Cookie"。


3）什么是Cookie
Cookie 是存储在用户浏览器中的一段"不超过4KB(大概4000个左右字母)"的字符串。它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie"有效期"、"安全性"、"使用范围"的可选属性组成。

不同"域名"下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有"未过期"的Cookie一同发送到服务器。

Cookie的几大特性:

1.自动发送
2.域名独立
3.过期时限
4.4KB限制


4）Cookie在身份认证中的作用
客户端第一次请求服务器的时候，服务器通过"响应头"的形式，向客户端发送一个身份认证的Cookie，客户端会"自动"将Cookie"保存"在浏览器中。

随后，当客户端浏览器每次请求服务器的时候，浏览器会"自动"将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。


5）Cookie"不具有"安全性
由于Cookie是存储在浏览器中的，而且浏览器也提供了读写Cookie的API，因此Cookie很容易被"伪造"，不具有安全性。因此不建议服务器将重要的隐私数据，通过Cookie 的形式发送给浏览器。

注意：千万不要使用Cookie存储重要且隐私的数据!比如用户的身份信息、密码等。


6）提高身份认证的安全性
为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在收银机上进行刷卡"认证"。只有收银机确认存在的会员卡，才能被正常使用。

这种“会员卡＋刷卡认证”的设计理念，就是"Session"认证机制的精髓。

7）Session的工作原理


- 在Express中使用Session认证

1.安装 express-session 中间件
在 Express 项目中，只需要安装 express-session 中间件，即可在项目中使用Session认证：

npm install express-session


2.配置express-session中间件
express-session中间件安装成功后，需要通过app.use()来注册session中间件，示例代码如下：

// 1．导入session中间件
var session = require('express-session')
// 2．配置Session中间件
app.use(session({
    secret: 'keyboard cat',            // secret属性的值可以为任意字符串
    resave: false,                    // 固定写法
    saveUninitialized: true            //固定写法
}))

3）向session中存数据
当express-session中间件配置成功后，即可通过req.session来访问和使用session对象，从而存储用户的关键信息：

app.post( '/api/login', (req, res) =>{
    // 判断用户提交的登录信息是否正确
    if (req.body.username !== 'admin' || req.body.password !== '000000') {
        return res.send({ status: 1, msg: "登录失败’})
    }
    req.session.user = req.body            //将用户的信息，存储到Session中
    req.session.islogin = true            //将用户的登录状态，存储到Session中
    res.send({ status: 0,msg: '登录成功'})
})


4）从session中取数据
可以直接从req.session对象上获取之前存储的数据，示例代码如下：

//获取用户姓名的接口
app.get( '/api/username ' , (req, res) =>{
    //判断用户是否登录
    if (!req.session.islogin) {
        return res.send({ status: 1,msg: 'fail'})
    }
    res.send({ status: 0，msg: 'success', username: req.session.user.username })
})

5）清空session
调用req.session.destroy()函数，即可清空服务器保存的session信息。

// 退出登录的接口
app.post( '/api/logout', (req,res) =>{
    //清空当前客户端对应的session信息
    req.session.destroy()
    res.send({
        status: 0,
        msg:'退出登录成功'
    })
})


- JWT认证机制

1）了解Session 认证的局限性

Session认证机制需要"配合"Cookie 才能实现。由于Cookie"默认不支持"跨域访问，所以，当涉及到"前端跨域请求后端接口"的时候，需要做很多额外的配置，才能实现跨域Session认证。


注意:

当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制。
当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用JWT认证机制。


2）什么是JWT
JWT(英文全称：JSON Web Token)是目前最流行的跨域认证解决方案。


3）JWT的工作原理
用户的信息通过Token字符串的形式，保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。


4）JWT的组成部分
JWT通常由三部分组成，分别是 Header (头部)、Payload (有效荷载)、Payload (签名)。

三者之间使用英文的“ . ”分隔，格式如下：
Header.Payload.Payload


5）JWT的三个部分各自代表的含义
JWT的三个组成部分，从前到后分别是 Header、Payload、Signature。


其中：
Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。Header和Signature是安全性相关的部分，只是为了保证Token的安全性。


6）JWT的使用方式
客户端收到服务器返回的WT之后，通常会将它储存在localStorage或 sessionStorage 中。

此后，客户端每次与服务器通信，都要带上这个WT的字符串，从而进行身份认证。推荐的做法是把JWT放在HTTP请求头的Authorization字段中，格式如下：

Authorization: Bearer <token>

- 在Express中使用JWT

1）安装JWT相关的包
运行如下命令，安装如下两个JWT相关的包:

npm install jsonwebtoken express-jwt

其中:

1.jsonwebtoken 用于生成JWT字符串
2.express-jwt 用于将JWT字符串解析还原成JSON对象

2）导入JWT 相关的包
使用require()函数，分别导入JWT相关的两个包:

// 1．导入用于生成JwT字符串的包
const jwt = require( 'jsonwebtoken')
// 2．导入用于将客户端发送过来的JWT字符串，解析还原成JSON对象的包
const expressJWT = require( 'express-jwt')


3）定义secret密钥
为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于"加密和解密"的secret密钥:

当生成JWT字符串的时候，需要使用secret密钥对用户的信息进行加密，最终得到加密好的WT字符串

当把JWT字符串解析还原成JSON对象的时候，需要使用secret"密钥"进行解密

// 3. secret密钥的本质:就是一个字符串
const secretKey = 'itheima No1 ^_^'


4）在登录成功后生成JWT字符串
调用jsonwebtoken包提供的 sign() 方法，将用户的信息加密成WT字符串，响应给客户端：

在登录成功之后，调用jwt.sign()方法生成JMT字符串。并通过 token 属性发送给客户端

参数1：用户的信息对象
参数2：加密的秘钥
参数3：配置对象，可以配置当前token的有效期


// 登录接口
app.post( '/api/login' , function(req,res) {
    // ..．省略登录失败情况下的代码
    //用户登录成功之后，生成JWT字符串，通过token属性响应给客户端
    res.send({
        status: 200,
        message: '登录成功!',
        //调用jwt , sign()生成JWT字符串，三个参数分别是:用户信息对象、加密密钥、配置对象
        token: jwt.sign({username: userinfo.username}， secretKey，{ expiresIn: '30h'))
    })
})


5）将JWT字符串还原为JSON对象
客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的Authorization字段,将Token字符串发送到服务器进行身份认证。

此时，服务器可以通过express-jwt这个中间件，自动将客户端发送过来的Token解析还原成JSON对象:
//使用app.use()来注册中间件
// expressJWT({ secret: secretKey }）就是用来解析Token的中间件
// .unless({ path:[/^\/api\//] })用来指定哪些接口不需要访问权限
app.use(expressJwT({ secret: secretKey }).unless({ path: [/^\/api\//] }))



#### （4）JWT认证机制

##### 1）了解Session 认证的局限性

Session认证机制需要配合Cookie 才能实现。由于Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证。

注意:

当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制。

当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用JWT认证机制。

##### 2）什么是JWT

JWT(英文全称：JSON Web Token)是目前最流行的跨域认证解决方案。

##### 3）JWT的工作原理

[外链图片转存中...(img-kxNUQozS-1659337778778)]

用户的信息通过Token字符串的形式，保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。

##### 4）JWT的组成部分

JWT通常由三部分组成，分别是 Header (头部)、Payload (有效荷载)、Payload (签名)。

三者之间使用英文的“ . ”分隔，格式如下：

```javascript
Header.Payload.Payload
