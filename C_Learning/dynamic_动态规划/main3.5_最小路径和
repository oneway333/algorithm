/*
 *
3.5 最小路径和
给定一个包含非负整数的m x n网格grid，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。

输入：grid = [[1,2,3],[4,5,6]]
输出：12
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7

 */

#include <stdio.h>

#define N 50

int min(int a, int b){
    return a < b ? a : b;
}

int path(int grid[][N], int m, int n){
    int dp[N][N] = {0};
    dp[m - 1][n - 1] = grid[m - 1][n - 1];
    // 初始化最后一行，最后一列，因为最后一行和最后一列只能向右或者下
    for (int i = n - 2; i >= 0; i--)
        dp[m - 1][i] = grid[m - 1][i] + dp[m - 1][i + 1];
    for (int i = m - 2; i >= 0; i--)
        dp[i][n - 1] = grid[i][n - 1] + dp[i + 1][n - 1];
    for (int i = m - 2; i >= 0; i--)
        for (int j = n - 2; j >= 0; j--)
            // 取向下或向右较小的那个
            dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) + grid[i][j];
    return dp[0][0];
}

int main(){

    int grid1[N][N] = {{1,2,3},{4,5,6}}, m1 = 2, n1 = 3;
    int grid2[N][N] = {{1,3,1},{1,5,1},{4,2,1}}, m2 = 3, n2 = 3;
    printf("%d\n", path(grid1, m1, n1));
    printf("%d\n", path(grid2, m2, n2));
    return 0;

}