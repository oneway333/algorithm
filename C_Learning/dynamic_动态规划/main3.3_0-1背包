/*
 *
3.3 0-1背包
已知有n种物品和可容纳c重量的背包，物品i的重量为wi且其产生的收益是pi。物品装包时，该物品不可以拆解即要么装要么不装。求出装包的最大收益。
输入：c = 10, w = [8,3,4,3], p = [9,3,4,3]
输出：10

 */

#include <stdio.h>

#define N 500


int bag(int c, int w[], int p[], int n){
    // 二维得写成这样
    int dp[N][N] = {0};
    // 初始化dp，dp为从第i件物品开始放入时，产生的最大收益
    for (int i = 0; i <= c; ++i)
        dp[n - 1][i] = w[n - 1] > i ? 0 : p[i];
    // 两个核心等式
    for (int i = n - 2; i >= 0; i--) {
        for (int j = 0; j <= c; ++j) {
            // 容量不够，第i个装不下，收益不变，等于装i + 1个物品
            if (j < w[i]) dp[i][j] = dp[i + 1][j];
            // 容量够，第i个装得下，收益为不装和装了（注意第i个装了，第i + 1个的收益可能会变化）的最大值
            else {
                int t = dp[i + 1][j - w[i]] + p[i];
                dp[i][j] = dp[i + 1][j] > t ? dp[i + 1][j] : t;
            }
        }
    }
    // 最终返回从第i个物品开始装，装满时的最大收益
    return dp[0][c];

}

int main(){

    int c = 10, w[] = {8, 3, 4, 3}, p[] = {9, 3, 4, 3}, n = 4;
    printf("%d\n", bag(c, w, p, n));
    return 0;

}