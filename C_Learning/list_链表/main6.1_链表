/*
 *
 * 链表的几个实现
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#define N 50
#define M 50

typedef struct node {
    int n;
    struct node *next;
} Node;

Node *newNode(int n) {
    Node *node = (Node *) malloc(sizeof(Node));
    node->n = n;
    node->next = NULL;
    return node;
}

Node *createList(int nums[], int n) {
    Node *head = NULL, *t = NULL, *p = NULL;
    for (int i = 0; i < n; ++i) {
        t = newNode(nums[i]);
        if (head == NULL) head = t;
        else p->next = t;
        p = t;
    }
    return head;
}

void show(Node *head) {
    while (head != NULL) {
        printf("%d\t", head->n);
        head = head->next;
    }
}

int len(Node *head) {
    int res = 0;
    while (head != NULL) {
        res++;
        head = head->next;
    }
    return res;
}

// 正着删除第k个元素
Node *delete1(Node *head, int k) {
    Node *v = newNode(0);
    v->next = head;
    Node *p = v;
    while (--k) p = p->next;
    p->next = p->next->next;
    return v->next;
}

// 倒着删除第k个元素
Node *delete2(Node *head, int k) {
    int n = len(head) - k;
    Node *v = newNode(0);
    v->next = head;
    Node *p = v;
    while (n--) p = p->next;
    p->next = p->next->next;
    return v->next;
}

/*
 *
 * 2.4 删除节点Ⅲ
        给定有序链表头指针head，删除链表里的重复元素，重复元素仅保留一个。
 */

Node *delete3(Node *head) {
    Node *p = head;
    while (p->next != NULL) {
        if (p->n != p->next->n) p = p->next;
        else {
            Node *t = p->next;
            // 可能空指针
            while (t != NULL && p->n == t->n) t = t->next;
            p->next = t;
        }
    }
    return head;
}

/*
 *
 * 2.5 删除节点Ⅳ
        给定有序链表头指针head，删除链表里的重复元素，重复的元素全部删除。
 *
 */

Node *delete4(Node *head) {
    // pl记录p上一次的状态
    Node *p, *pl = NULL;
    p = head;
    while (p != NULL && p->next != NULL) {
        if (p->n != p->next->n) {
            pl = p;
            p = p->next;
        } else {
            // t
            Node *t = p->next;
            while (t != NULL && p->n == t->n) t = t->next;
            // p为头的时候，要移动head
            if (p == head) head = t;
            // 用pl来进行重复数字的删除
            if (pl != NULL) pl->next = t;
            p = t;
        }

    }
    return head;
}

/*
 2.6 插入排序
给定链表头指针head，对链表进行插入排序。
 *
 */

Node *numNode(Node *head, int i){
    Node *p = head;
    while (i--) p = p->next;
    return p;
}

// 升序
Node *sort(Node *head){
    int n = len(head);
    Node *pk, *pi;
    for (int i = 0; i < n -1; ++i) {
        int k = i;
        pi = numNode(head, i);
        for (int j = i + 1; j < n; ++j) {
            if (numNode(head, k)->n > numNode(head, j)->n) k = j;
        }
        if (k != i){
            pk = numNode(head, k);
            int t = pk->n;
            pk->n = pi->n;
            pi->n = t;
        }
    }
    return head;
}

/*
 *
 *
 * 2.7 环的入口
给定链表头指针head，若链表存在环，找出链表入环的第一个节点，否则返回NULL。

 枚举
 */
Node *enter(Node *head){
    Node *nodes[N], *p = head;
    int n = 0;
    while (p != NULL){
        for (int i = 0; i < n; ++i)
            if (p == nodes[i]) return p;
        nodes[n++] = p;
        p = p->next;
    }
    return NULL;
}

/*
 *
 * 2.8 链表分隔
给定链表的头指针head和一个特定值x，请你对链表进行分隔，使得所有小于x的节点都出现在大于或等于x的节点之前。
 *
 *
 * 暴力
 */

Node *divide(Node *head, int x){
    int nums[N] = {0};
    Node *s = createList(nums, N), *b = createList(nums, N);
    Node *vs = newNode(0), *vb = newNode(0);
    vs->next = s;
    vb->next = b;
    Node *ps = vs, *pb = vb;
    while (head != NULL){
        if (head->n < x) {
            ps->next->n = head->n;
            ps = ps->next;
        }
        else {
            pb->next->n = head->n;
            pb = pb->next;
        }
        head = head->next;
    }
    ps->next = b;
    pb->next = NULL;
    return s;

}



int main() {
    int nums[] = {1, 2, 3, 4, 5, 6}, n = sizeof(nums) / sizeof(int);
    int nums1[] = {1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 7, 7, 9, 9, 9}, n1 = sizeof(nums1) / sizeof(int);
    int nums2[] = {2, 9, 1, 3, 5, 7, 9, 6}, n2 = sizeof(nums2) / sizeof(int);
    Node *head = createList(nums, n);
    Node *t2 = head, *t6 = head;
    for (int i = 0; i < 1; ++i) t2 = t2->next;
    for (int i = 0; i < 5; ++i) t6 = t6->next;
    t6->next = t2;
//    show(head);
//    printf("%d", enter(head)->n); // 进入还

    Node *head1 = createList(nums1, n1);
//    Node *head2 = createList(nums2, n2); // 排序
//    show(divide(head2, 4));
//    show(delete1(head, 4));
//    show(delete2(head, 3));
//    show(delete3(head1));
    show(delete4(head1));
//    show(sort(head2));// 排序
//    printf("%d", len(head));

}