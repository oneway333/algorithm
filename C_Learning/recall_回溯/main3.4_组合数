/*
 *
3.4 组合数
给你一个无重复元素的非负整数数组nums和一个目标整数target，找出nums中可以使数字和为目标数target的所有不同组合 ，并将它们输出出来，每个元素可以使用多次，你可以按任意顺序输出这些组合。
输入：nums = [2,3,6,7], target = 7
输出：[[2,2,3], [7]]
输入: nums = [2,3,5], target = 8
输出: [[2,2,2,2], [2,3,3], [3,5]]


 */

#include <stdio.h>

#define N 500

int path[N];
int sum;

void sort(int a[], int n){
    for (int i = 0; i < n - 1; ++i) {
        int k = i;
        for (int j = i + 1; j < n; ++j) if (a[k] > a[j]) k = j;
        if (k != i){
            int t = a[k];
            a[k] = a[i];
            a[i] = t;
        }
    }
}

void combine(int nums[], int n, int target, int k, int begin){
    if (sum == target) {
        for (int i = 0; path[i]; ++i) printf("%d ", path[i]);
        putchar('\n');
        return;
    }
    for (int i = 0; i < n; ++i) {
        if (nums[i] < begin) continue;
        if (sum > target) return;
        path[k] = nums[i];
        sum += path[k];
        combine(nums, n, target, k + 1, path[k]);
        sum -= path[k];
        path[k] = 0;
    }
}

int main(){
    int nums1[] = {2, 3, 6, 7}, n1 = 4, target1 = 7;
    int nums2[] = {2, 3, 5}, n2 = 3, target2 = 8;
    sort(nums1, n1);
    sort(nums2, n2);

    combine(nums1, n1, target1, 0, 0);
    combine(nums2, n2, target2, 0, 0);
    return 0;
}