/*
 *
3.8 多机调度问题
设n个独立作业由m台机器M1、M2、M3、...、Mm加工处理。各作业所需的处理时间由数组nums指定，求所有作业全部完成的最短时间是多少。
输入：m = 3, nums = [2,14,4,16,6,5,3]
输出：17

思考：如果要求计算最小花费，如何计算？
即假设，机器在运行某个作业的时候，其他空闲作业未产生单位成本（每等1h，成本增加1）
此时要将nums升序排序，先初始化mach[0], mach[1], mach[2]...mach[m], 然后找出最小的那个任务（最快结束，并能最先分配），令res += 最小任务的时长，重复上述操作，最后加上所有任务的总和
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#define N 50
#define M 50

void sort(int a[], int n){
    for (int i = 0; i < n - 1; ++i) {
        int k = i;
        for (int j = i + 1; j < n; ++j)
            if (a[k] < a[j]) k = j;
        if (k != i){
            int t = a[k];
            a[k] = a[i];
            a[i] = t;
        }
    }
}

int min(int nums[], int n, int m){
    int mach[N] = {0};//初始化N台机器
    // 降序
    sort(nums, n);
    // 标记哪个机器最闲
    int idx = 0;
    // 把作业放入最空闲的那台机器
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j)
            if (mach[j] < mach[idx]) idx = j;
        mach[idx] += nums[i];
    }
    // 找出3台机器耗时最长的
    int i, j;
    for (i = 0, j = 0; i < m; ++i)
        if (mach[i] > mach[j]) j = i;
    return mach[j];
}

int main(){
    int m = 3, nums[] = {2,14,4,16,6,5,3}, n = 7;
    printf("%d", min(nums, n, m));
    return 0;
}