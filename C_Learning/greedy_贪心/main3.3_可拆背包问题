/*
 *
3.3 可拆背包问题
已知有n种物品和可容纳c重量的背包，物品i的重量为wi且其产生的收益是pi。物品装包时，该物品可以拆解即可以仅装该物品的一部分。求出装包的最大收益。
输入：c = 10, w = [2, 2, 10, 5, 4], p = [6, 3, 5, 4, 6]
输出：16.6
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#define N 50

typedef struct{
    int w, p;
    double sp;
} Item;

void sort(Item item[], int n){
    for (int i = 0; i < n - 1; ++i) {
        int k = i;
        for (int j = i + 1; j < n; ++j)
            if (item[k].sp < item[j].sp) k = j;
        if (k != i){
            Item t = item[k];
            item[k] = item[i];
            item[i] = t;
        }
    }
}

double package(int w[], int p[], int c, int n){
    Item item[5];
    double bene = 0.0;
    // 循环变量
    int i = 0;
    for (int i = 0; i < n; ++i) {
        item[i].w = w[i];
        item[i].p = p[i];
        item[i].sp = 1.0 * p[i] / w[i];
    }
    // 按照单价降序排序
    sort(item, n);
    while (c){
        // 如果重量不够，就用剩余的重量来充当最后的重量，这一步挺神的
        int in = c > item[i].w ? item[i].w : c;
        bene += in * item[i].sp;
        i++;
        c -= in;
    }
    return bene;
}

int main(){
    int w[] = {2, 2, 10, 5, 4}, p[] = {6, 3, 5, 4, 6}, c = 10, n = 5;
    printf("%lf", package(w, p , c, n));
    return 0;

}