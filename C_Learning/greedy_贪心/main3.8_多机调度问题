/*
3.8 多机调度问题
设n个独立作业由m台机器M1、M2、M3、...、Mm加工处理。各作业所需的处理时间由数组nums指定，求所有作业全部完成的最短时间是多少。
输入：nums = [2,14,4,16,6,5,3]
输出：17
 *
 */


#include <stdio.h>
#include "string.h"
#include <stdlib.h>

#define N 500
#define M 3

// 降序排序
void sort(int nums[], int n){
    for (int i = 0; i < n - 1; ++i) {
        int k = i;
        for (int j = i + 1; j < n; ++j) {
            if (nums[k] < nums[j]) k = j;
        }
        if (k != i){
            int t = nums[k];
            nums[k] = nums[i];
            nums[i] = t;
        }
    }
}

int find(int mach[], int m){
    int idx, res = 0;
    // 将idx初始化为第一个不为0的下标
    for (idx = 0; idx < m; ++idx) {
        if (mach[idx] != 0) break;
    }
    for (int i = 1; i < m; ++i) {
        if (mach[i] != 0 && mach[idx] > mach[i]) idx = i;
    }
    res = mach[idx];
    for (int i = 0; i < m; ++i) {
        mach[i] -= res;
    }
    return res;
}

void change(int mach[], int nums[], int m, int n, int idx){
    for (int i = 0; i < m; ++i) {
        // 如果一个作业结束，从nums里面拿下一个（m+idx）
        if (mach[i] == 0) mach[i] = nums[m + idx];
    }
}

int output(int nums[], int n){
    // 降序排序
    sort(nums, n);
    // 初始化m台机器，表示剩余多久做完，先放入时间最长的三个作业
    int mach[] = {nums[0], nums[1], nums[2]};
    int res = 0;
    for (int i = 0; i < n - 1; ++i) {
        // 每次加mach中做完的时间，并修改mach，加入下一个作业
        res += find(mach, M);
        // 对mach进行修改，加入新作业
        change(mach, nums, M, n, i);
    }
    return res;
}

int main() {
    int nums[] = {2,14,4,16,6,5,3}, n = 7;
    printf("%d", output(nums, n));
    return 0;
}