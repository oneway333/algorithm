webpack使用

第一步：初始化参数，从配置文件和shell语句中读取，和合并我们的参数，得到最终的一个参数。
第二步：开始编译，用上一步得到的这个参数初始化compiler这个对象，去加载我们所有配置的一个插件，执行我们对象的一个run方法，开始进入编译阶段。
第三步：确定入口，根据我们配置中的entry，找出我们所有的一个入口文件。
第四步：编译模块，从入口文件出发。调用我们所有配置的一个loader对模块进行一个编译，再找出该模块所依赖的模块，递归这个步骤，直到所有的入口的依赖的文件都经过这个第四步的一个处理。




启用 Webpack

开发模式
npx webpack ./src/main.js --mode=development

生产模式
npx webpack ./src/main.js --mode=production

注意：
npx webpack: 是用来运行本地安装 Webpack 包的。
./src/main.js: 指定 Webpack 从 main.js 文件开始打包，不但会打包 main.js，还会将其依赖也一起打包进来。
--mode=xxx：指定模式（环境）。

#5. 观察输出文件
默认 Webpack 会将文件打包输出到 dist 目录下，我们查看 dist 目录下文件情况就好了

小结
Webpack 本身功能比较少，只能处理 js 资源，一旦遇到 css 等其他资源就会报错。
所以我们学习 Webpack，就是主要学习如何处理其他资源。

======================================================

基本配置

在开始使用 Webpack 之前，我们需要对 Webpack 的配置有一定的认识。

5 大核心概念
entry（入口）
指示 Webpack 从哪个文件开始打包

output（输出）
指示 Webpack 打包完的文件输出到哪里去，如何命名等

loader（加载器）
webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析

plugins（插件）
扩展 Webpack 的功能

mode（模式）
主要由两种模式：

开发模式：development
生产模式：production


准备 Webpack 配置文件

在项目根目录下新建文件：webpack.config.js

module.exports = {
  // 入口
  entry: "",
  // 输出
  output: {},
  // 加载器
  module: {
    rules: [],
  },
  // 插件
  plugins: [],
  // 模式
  mode: "",
};

Webpack 是基于 Node.js 运行的，所以采用 Common.js 模块化规范

修改配置文件

配置文件

// Node.js的核心模块，专门用来处理文件路径
const path = require("path");

module.exports = {
  // 入口
  // 相对路径和绝对路径都行
  entry: "./src/main.js",
  // 输出
  output: {
    // path: 文件输出目录，必须是绝对路径
    // path.resolve()方法返回一个绝对路径
    // __dirname 当前文件的文件夹绝对路径
    path: path.resolve(__dirname, "dist"),
    // filename: 输出文件名
    filename: "main.js",
  },
  // 加载器
  module: {
    rules: [],
  },
  // 插件
  plugins: [],
  // 模式
  mode: "development", // 开发模式
};

npx webpack

开发模式介绍
开发模式顾名思义就是我们开发代码时使用的模式。

这个模式下我们主要做两件事：

编译代码，使浏览器能识别运行
开发时我们有样式资源、字体图标、图片资源、html 资源等，webpack 默认都不能处理这些资源，所以我们要加载配置来编译这些资源

代码质量检查，树立代码规范
提前检查代码的一些隐患，让代码运行时能更加健壮。

提前检查代码规范和格式，统一团队编码风格，让代码更优雅美观。


======================================================

处理样式资源
本章节我们学习使用 Webpack 如何处理 Css、Less、Sass、Scss、Styl 样式资源

#介绍
Webpack 本身是不能识别样式资源的，所以我们需要借助 Loader 来帮助 Webpack 解析样式资源

我们找 Loader 都应该去官方文档中找到对应的 Loader，然后使用

官方文档找不到的话，可以从社区 Github 中搜索查询

处理 Css 资源
1. 下载包

npm i css-loader style-loader -D

注意：需要下载两个 loader

2.功能介绍
css-loader：负责将 Css 文件编译成 Webpack 能识别的模块
style-loader：会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容
此时样式就会以 Style 标签的形式在页面上生效

Eslint
可组装的 JavaScript 和 JSX 检查工具。

这句话意思就是：它是用来检测 js 和 jsx 语法的工具，可以配置各项功能

我们使用 Eslint，关键是写 Eslint 配置文件，里面写上各种 rules 规则，将来运行 Eslint 时就会以写的规则对代码进行检查


Babel
JavaScript 编译器。

主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中


======================================================

生产模式介绍

生产模式是开发完成代码后，我们需要得到代码将来部署上线。

这个模式下我们主要对代码进行优化，让其运行性能更好。

优化主要从两个角度出发:

优化代码运行性能
优化代码打包速度

运行开发模式的指令：
这个是启动一个服务器，--config表示读取某一个配置文件，各种开发配置都在这个js里面写好了  
npx webpack serve --config ./config/webpack.dev.js


运行生产模式的指令：

npx webpack --config ./config/webpack.prod.js

4. 配置运行指令
为了方便运行不同模式的指令，我们将指令定义在 package.json 中 scripts 里面

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "npx webpack serve --config ./config/webpack.dev.js",
    "build": "npx webpack --config ./config/webpack.prod.js"
  },

  ======================================================


Css 处理
#提取 Css 成单独文件
Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式

这样对于网站来说，会出现"闪屏现象"，用户体验不好

我们应该是单独的 Css 文件，通过 link 标签加载性能才好

npm i mini-css-extract-plugin -D


Css 兼容性处理


npm i postcss-loader postcss postcss-preset-env -D

控制兼容性
我们可以在 package.json 文件中添加 browserslist 来控制样式的兼容性做到什么程度。

Css 压缩
#1. 下载包

npm i css-minimizer-webpack-plugin -D

总结
本章节我们学会了 Webpack 基本使用，掌握了以下功能：

两种开发模式
开发模式：代码能编译自动化运行
生产模式：代码编译优化输出

Webpack 基本功能
开发模式：可以编译 ES Module 语法
生产模式：可以编译 ES Module 语法，压缩 js 代码

Webpack 配置文件
5 个核心概念
entry
output
loader
plugins
mode

devServer 配置

Webpack 脚本指令用法
webpack 直接打包输出
webpack serve 启动开发服务器，内存编译打包没有输出


======================================================

高级优化

本章节主要介绍 Webpack 高级配置。

所谓高级配置其实就是进行 Webpack 优化，让我们代码在编译/运行时性能更好~

我们会从以下角度来进行优化：

提升开发体验
提升打包构建速度
减少代码体积
优化代码运行性能


SourceMap（源代码映射）是一个用来生成源代码与构建后代码一一映射的文件的方案。

它会生成一个 xxx.map 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。
当构建后代码出错了，会通过 xxx.map 文件，从构建后代码出错位置找到映射后源代码出错位置，
从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源。

怎么用？

SourceMap 的值有很多种情况.

但实际开发时我们只需要关注两种情况即可：

开发模式：cheap-module-source-map

优点：打包编译速度快，只包含行映射
缺点：没有列映射

module.exports = {
  // 其他省略
  mode: "development",
  devtool: "cheap-module-source-map",
};


生产模式：source-map
优点：包含行/列映射
缺点：打包编译速度更慢

module.exports = {
  // 其他省略
  mode: "production",
  devtool: "source-map",
};


HotModuleReplacement
#为什么
开发时我们修改了其中一个模块代码，Webpack 默认会将所有模块全部重新打包编译，速度很慢。

所以我们需要做到修改某个模块代码，就只有这个模块代码需要重新打包编译，其他模块不变，这样打包速度就能很快。

#是什么
HotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。

OneOf
为什么
打包时每个文件都会经过所有 loader 处理，虽然因为 test 正则原因实际没有处理上，但是都要过一遍。比较慢。

#是什么
顾名思义就是只能匹配上一个 loader, 剩下的就不匹配了。


Include/Exclude
开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中了。而这些文件是不需要编译可以直接使用的。

所以我们在对 js 文件处理时，要排除 node_modules 下面的文件。

#是什么
include
包含，只处理 xxx 文件

exclude
排除，除了 xxx 文件以外其他文件都处理


Cache
#为什么
每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。

我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了。

#是什么
对 Eslint 检查 和 Babel 编译结果进行缓存


Thead
#为什么
当项目越来越庞大时，打包速度越来越慢，甚至于需要一个下午才能打包出来代码。这个速度是比较慢的。

我们想要继续提升打包速度，其实就是要提升 js 的打包速度，因为其他文件都比较少。

而对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。

我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了。

#是什么
多进程打包：开启电脑的多个进程同时干一件事，速度更快。

需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销。

#怎么用
我们启动进程的数量就是我们 CPU 的核数。

如何获取 CPU 的核数，因为每个电脑都不一样。

// nodejs核心模块，直接使用
const os = require("os");
// cpu核数
const threads = os.cpus().length;
下载包

npm i thread-loader -D


======================================================

减少代码体积
#Tree Shaking
#为什么
开发时我们定义了一些工具函数库，或者引用第三方工具函数库或组件库。

如果没有特殊处理的话我们打包时会引入整个库，但是实际上可能我们可能只用上极小部分的功能。

这样将整个库都打包进来，体积就太大了。

#是什么
Tree Shaking 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码。

注意：它依赖 ES Module。

#怎么用
Webpack 已经默认开启了这个功能，无需其他配置


Babel
#为什么
Babel 为编译的每个文件都插入了辅助代码，使代码体积过大！

Babel 对一些公共方法使用了非常小的辅助代码，比如 _extend。默认情况下会被添加到每一个需要它的文件中。

你可以将这些辅助代码作为一个独立模块，来避免重复引入。

#是什么
@babel/plugin-transform-runtime: 禁用了 Babel 自动对每个文件的 runtime 注入，
而是引入 @babel/plugin-transform-runtime 并且使所有辅助代码从这里引用

怎么用
下载包

npm i @babel/plugin-transform-runtime -D



Image Minimizer
#为什么
开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。

我们可以对图片进行压缩，减少图片体积。

注意：如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。

#是什么
image-minimizer-webpack-plugin: 用来压缩图片的插件


怎么用
下载包

npm i image-minimizer-webpack-plugin imagemin -D
还有剩下包需要下载，有两种模式：

无损压缩

npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D


有损压缩

npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D


打包时会出现报错：

Error: Error with 'src\images\1.jpeg': '"C:\Users\86176\Desktop\webpack\webpack_code\node_modules\jpegtran-bin\vendor\jpegtran.exe"'
Error with 'src\images\3.gif': spawn C:\Users\86176\Desktop\webpack\webpack_code\node_modules\optipng-bin\vendor\optipng.exe ENOENT
我们需要安装两个文件到 node_modules 中才能解决, 文件可以从课件中找到：

jpegtran.exe
需要复制到 node_modules\jpegtran-bin\vendor 下面

jpegtran 官网地址

optipng.exe
需要复制到 node_modules\optipng-bin\vendor 下面

OptiPNG 官网地址



Code Split
#为什么
打包代码时会将所有 js 文件打包到一个文件中，体积太大了。我们如果只要渲染首页，就应该只加载首页的 js 文件，其他文件不应该加载。

所以我们需要将打包生成的文件进行代码分割，生成多个 js 文件，渲染哪个页面就只加载某个 js 文件，这样加载的资源就少，速度就更快。

#是什么
代码分割（Code Split）主要做了两件事：

分割文件：将打包生成的文件进行分割，生成多个 js 文件。
按需加载：需要哪个文件就加载哪个文件。
#怎么用
代码分割实现方式有不同的方式，为了更加方便体现它们之间的差异，我们会分别创建新的文件来演示


总结
我们从 4 个角度对 webpack 和代码进行了优化：

提升开发体验
使用 Source Map 让开发或上线时代码报错能有更加准确的错误提示。提升 webpack 提升打包构建速度
使用 HotModuleReplacement 让开发时只重新编译打包更新变化了的代码，不变的代码使用缓存，从而使更新速度更快。
使用 OneOf 让资源文件一旦被某个 loader 处理了，就不会继续遍历了，打包速度更快。
使用 Include/Exclude 排除或只检测某些文件，处理的文件更少，速度更快。
使用 Cache 对 eslint 和 babel 处理的结果进行缓存，让第二次打包速度更快。
使用 Thead 多进程处理 eslint 和 babel 任务，速度更快。（需要注意的是，进程启动通信都有开销的，要在比较多代码处理时使用才有效果）
减少代码体积
使用 Tree Shaking 剔除了没有使用的多余代码，让代码体积更小。
使用 @babel/plugin-transform-runtime 插件对 babel 进行处理，让辅助代码从中引入，而不是每个文件都生成辅助代码，从而体积更小。
使用 Image Minimizer 对项目中图片进行压缩，体积更小，请求速度更快。（需要注意的是，如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。）
优化代码运行性能
使用 Code Split 对代码进行分割成多个 js 文件，从而使单个文件体积更小，并行加载 js 速度更快。并通过 import 动态导入语法进行按需加载，从而达到需要使用时才加载该资源，不用时不加载资源。
使用 Preload / Prefetch 对代码进行提前加载，等未来需要使用时就能直接使用，从而用户体验更好。
使用 Network Cache 能对输出资源文件进行更好的命名，将来好做缓存，从而用户体验更好。
使用 Core-js 对 js 进行兼容性处理，让我们代码能运行在低版本浏览器。
使用 PWA 能让代码离线也能访问，从而提升用户体验。
















1.能够理解webpack基本概念和作用
2.能够掌握webpack使用步骤
3.能够使用webpack相关配置
4.能够使用webpack开发服务器
5.能够查阅使用webpack中文文档

* webpack本身是, node的一个第三方（插件？）模块包, 用于打包代码

官网 https://webpack.docschina.org/

现代 javascript 应用程序的 静态模块打包器 (module bundler)
为要学的 vue-cli 开发环境做铺垫

* webpack能做什么
把很多文件打包整合到一起, 缩小项目体积, 提高加载速度

** less/sass -> css
** ES6/7/8 -> ES5 处理js兼容
** 支持js模块化
** 处理css兼容性
** html/css/js -> 压缩合并

* webpack的基本使用

* 创建项目


* webpack使用

** 初始化包环境
npm install

** 安装依赖包
npm install webpack webpack-cli -D

** package.json 中配置scripts(自定义命令)

"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
  "build": "webpack"
},

** 测试一下
npm run test

** 运行打包命令
npm run build

执行打包命令后，在src并列处, 生成默认dist目录和打包后默认main.js文件,默认会打包src下的index.js


* webpack 更新打包

以后代码变更, 如何重新打包呢？

** 重新打包: npm run build

1.src下开发环境, dist是打包后, 分别独立
2.打包后格式压缩, 变量压缩等


【webpack的配置】

* webpack-入口和出口
告诉webpack从哪开始打包, 打包后输出到哪里

默认入口: ./src/index.js

默认出口: ./dist/main.js

webpack配置: webpack.config.js(默认)

1.新建src并列处, webpack.config.js

module.exports = {
   mode: '',
   entry: '',
   output: '',
   plugins: [],
   module: [],
   resolve: '',
   devServer: {}
}

2.填入配置项

const path = require("path")

module.exports = {
    entry: "./src/main.js", // 入口
    output: { 
        path: path.join(__dirname, "dist"), // 出口路径
        filename: "bundle.js" // 出口文件名
    }
}

3.修改package.json, 自定义打包命令 - 让webpack使用配置文件

重点: 所有要被打包的资源都要跟入口产生直接/间接的引用关系


* 插件-自动生成html文件

html-webpack-plugin插件, 让webpack打包后生成html文件并自动引入打包后的js

1.下载插件：
npm install html-webpack-plugin  -D

2.webpack.config.js配置

3.重新打包后观察dist下是否多出html并运行看效果
打包后的index.html自动引入打包后的js文件

4.自定义打包的html模版，和输出文件名字
plugins: [
  new HtmlWebpackPlugin({
    template: './public/index.html',
    filename: 'index.html'
  })
]


5 mode模式

mode模式分为开发阶段和发布阶段
development 开发阶段，简易打包，打包速度快
production  发布阶段，打包精细，打包速度慢（但是没关系不会经常production）


【webpack开发服务器-为何学?】

* 问题：每次修改代码, 都需要重新 npm run build 打包, 才能看到最新的效果, 实际工作中, 打包 npm run build 非常费时 (30s - 60s) 之间
为什么费时?
1.构建依赖
2.磁盘读取对应的文件到内存, 才能加载
3.将处理完的内容, 输出到磁盘指定目录

* 解决方法: 起一个开发服务器, 在电脑"内存中打包", 缓存一些已经打包过的内容, 只重新打包修改的文件, 最终运行加载在内存中给浏览器使用


【webpack-dev-server】

* 启动本地服务, 可实时更新修改的代码, 打包变化代码到内存中, 然后直接提供端口和网页访问

1.下载包

npm install webpack-dev-server -D

2.package.json中配置

"scripts": {
    "build": "webpack",
    "serve": "webpack serve"
}

3.运行命令-启动webpack开发服务器
npm run serve

以后改了src下的资源代码, 就会直接更新到内存打包, 然后反馈到浏览器上了

* webpack-dev-server配置

1.package.json
"scripts": {
  "build": "webpack",
  "serve": "webpack serve --port 8083 --open"
},


2.在webpack.config.js中添加服务器配置

module.exports = {
    // ...其他配置
    devServer: {
      port: 3000, // 端口号
      open: true
    }
}


// "serve": "webpack serve --port 8080 --open"


【加载器 - 处理css文件问题】

自己准备css文件, 引入到webpack入口, 测试webpack是否能打包css文件

1.新建 - src/styles/index.css

2.编写样式

3.(重要) 一定要引入到入口才会被webpack打包

4.执行打包命令观察效果

总结: 保存原因, 因为webpack默认只能处理js类型文件


【加载器 - 处理css文件】

loaders加载器, 可让webpack处理其他类型的文件, 打包到js中

1.安装依赖
npm install style-loader css-loader -D

万物皆模块, 引到入口, 才会被webpack打包, css打包进js中, 然后被嵌入在style标签插入dom上




















