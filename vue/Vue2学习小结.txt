Vue

Vue2 的vue-router不能用4版本以上的

Node.js的版本要注意下

Vue2内部的变量感觉要么从this获取，要么从event获取
Vue3不同，更多的需要写函数，还得记得返回

数据代理，数据劫持？
Vue是怎样实现数据监视的？应该也就是通过给每个属性（无论是字面量、函数、对象）套上set get方法，获取的时候都需要调用set和get方法。这样在get和set中就有那么一段神奇的逻辑，监视着这些数据的变化，然后来渲染页面

MVVM：M model 模型数据  V view 视图  VM 实例对象，控制模型数据变化，刷新视图

vue-cli安装vue，这样就创建了一个 app 为名字的目录
vue create app 


Vue2 后台管理系统模板
https://github.com/PanJiaChen/vue-admin-template    简洁版模板
https://github.com/PanJiaChen/vue-element-admin     加强版模板


==================================一些面试题===================================

* vue中的data为什么是一个函数

Vue 中的 data 必须是个函数，因为当 data 是函数时，"组件实例化"的时候"这个函数将会被调用"，返回一个对象，计算机会给这个对象分配一个内存地址，实例化几次就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。
简单来说，就是为了保证"组件的独立性和可复用性"，如果 data 是个函数的话，每复用一次组件就会返回新的 data，类似于给每个组件实例创建一个私有的数据空间，保护各自的数据互不影响.

实际上就是一个"闭包"，因为vue是单页面应用，是由很多组件构成，每一个组件中都有一个data，所以通过闭包给每一个组件创建了一个"私有的作用域"，这样就不会相互影响。



* Vue组件间通信方式

props 属性的方式
emit  自定义事件
$attrs vue3的祖孙传参
$parent $root
ref 
全局事件总线
vuex
pinia


* v-if v-for 优先级

不推荐一起使用

一个节点上时：

v-if读不到todo，会报错，
<li v-for='todo in todos' v-if='!todo.isComplete'></li>

解决办法

这个时候就可以读到了
<template  v-for='todo in todos'>
    <li v-if='!todo.isComplete'></li>
</template>


Vue2 v-for > v-if
Vue3 v-if > v-for


* Vue生命周期

- beforeCreate
- created
- beforeMount
- mounted
- beforeUpate
- updated
- beforeDestory
- destoryed

- activated   keep-alive 激活的时候
- deactivated
- errorCaptured   错误监听  vue.config.errorHandler
- renderTracked renderTriggered  serverPrefetch

- nextTick  专门用来给input focus的


* 双向绑定

1. v-model  双向绑定
2. v-model :value @input
3. <input v-model='str' type='text'>


* Vue 响应式

Vue2 Object.defineProperty()  getter setter Vue.$set
Vue3 Proxy


* Vue模板渲染原理

template {{  }} -> compiler js 模板编译

js -> cross-platform

1. parse template 解析成完成的对象 AST
2. AST -> 哪些节点发生改变 打标记tag diff打标记的节点 runtime
3. generate AST -> render


* template jsx区别


* Vue2 和 Vue3 的区别

1. 重写响应式 Object.defineProperty -> Proxy
2. composition api 函数式编程 hooks 
3. 虚拟DOM diff 双端比较 -> 最长递增子序列
4. flow -> ts
5. tree shaking
6. template compiler 编译


=======================================================================================

全局过滤器
Vue.filter('filter', function(val){return new_val})
通过在双大括号中，{{name | filter}} 来实现过滤


双大括号
{{js表达式}}
可以写{{data中的属性}}，{{n++}}, {{}}

adfasdfasdfasdfsfdf

@click="showInfo"    // 双引号里面也可以写js表达式
@click="showInfo1($event, 321)"  // 回调函数可以配置多个参数，事件对象要加$event
class="basic" :class="class_style1"    // 绑定样式
<h2 :style="{opacity}">fuck you</h2>    // 通过style绑定样式，要用对象形式的写法

一般结构：

body中：

<div id="root">
</div>

script中：
new Vue({
    el:'#root',
    data: {
        name: 'fuck',    // 绑定的属性变量
        class_style1: [],   // 样式的数组
        class_style2: {css1: true, css2:false},   // 样式的对象
    },
    methods: {
        // 事件的回调函数，和js一样，会传入事件对象，用法相同
        showInfo1(e){
            console.log(e.target);
            console.log(e.target.textContent);
        },
        showInfo2:(e) => { 
            console.log(this); // this指向window，所以尽量不要使用箭头函数
        },
        showInfo3(e, num){
            console.log(num);  // 回调函数可以配置多个参数，此处可以接收
        },
        change_mood(){
            this.class_style1.push('fuck1')    // 将这些样式添加进class中
            this.class_style1.push('fuck2')
            this.class_style1.push('fuck3')
        }
    },
    computed: {    // 计算属性
        full1: {
            get(){
                return this.fuck + '-' + this.you   // 通过this拿到data中的数据，需要return
            },
            // 当full被修改时调用，要传入一个val值
            set(val){
                // 要改data中的数据全都要改
                let t = val.split('-')
                this.fuck = t[0]
                this.you = t[1]
            }
        },
        full2(){    // 计算属性通常只会get，所以这是只有get功能的简写形式
            return 'XXX'
        }
    },
    // 计算属性更适合属性是由其他属性变化而来的情况
    // 计算属性一开始就会执行，不会出现监视属性第一次不执行的情况
    // 监视适合对当前属性的变化进行监视，从而影响其他的属性（好像也没说明白）
    watch: {
        name1: {
            deep:true,  // 深度监视，当name为obj的时候，其中的每个属性变化都会触发
            immediate: true,    // 在handler执行之前会执行一次
            handler(new_val, old_val){    // 两个参数，也可以传入一个参数，一个参数就是new_val
                console.log(new_val, old_val);
            }
        },
        // 当不需要配置除了handler之外的其他属性的时候可以采取简写形式
        name2(new_val, old_val) {
            console.log(new_val, old_val);
        }
    },
})


指令
v-bind      单向数据绑定，数据变但是data不变，v-bind:XXX="XXX" 简写 :XXX="xxxx"
            想要使得 “” 中是js表达式返回时，就使用v-bind，用途还是很广的
            不仅可以返回字符串，数组，数字，布尔值，对象，都可以

v-model     双向数据绑定，数据变data也变，v-model:value="XXX" 简写 v-model="xxxx"    
            一般用于input中绑定value
            input为radio时的数据绑定：
             <input type="radio" name="gender" v-model="gender" value="male">
             
            input为checkbox时的数据绑定：
            <input type="checkbox" v-model="hobby" value="fuck1">
            
            select的数据绑定：
            <select v-model="city">
            通过number修饰符确保step的数据类型
            <select v-model.number="step">
            
            textarea的数据绑定，lazy修饰符表示当textares失去焦点时更新vue的data：
            <textarea v-model.lazy="other" v-model="other">
            
            单个checkbox中，v-model绑定的是checked，默认为false
            <input type="checkbox" v-model="agree">
            
            绑定表单提交的事件，pervent阻止默认事件的修饰符
            <form action="" @submit.prevent="demo">
            
            
            
v-for       列表渲染：(element, index) of/in arr/obj/str/num  相当神奇的写法
            key的数据绑定是为了diff算法优化数据刷新的逻辑
            <ul v-for="p of persons" :key="p.id/index">
            <li>
                {{p.name}}-{{p.age}}-{{p.id}}
                <input type="text">    <!-- 如果有key属性，input中的值会进行保留，也就是diff算法的优化 -->
            </li>
            </ul>


v-on        事件处理：v-on:click="XXX"，简写：@click="XXX"
            修饰符：.prevent 阻止默认事件   
                    .stop 阻止冒泡    
                    .once 只发生一次
            键盘事件：@keyup @keydown, tab这种有默认效果的，最好用keydown


v-show      是否展示，相当于display: none，组件一直存在着，不用担心
v-if        主要是会删除节点，相当于 DPM中的 element.remove()，也就是组件会被销毁，会触发生命周期的destory或者unmount
v-else-if   成立必须当前节点的上一个兄弟节点有v-if修饰，因此下方div之间不能有除了空白节点之外的任何东西
v-else

v-text      将内容完全当文本插入标签中，怀疑用的是textContent
            name='shit'
            <h1 v-text="name">fuck</h1>
v-html      将内容解析为标签插入到内容中
            str: "<h2>damn</h2>"
            <h1 v-html="str">fuck</h1>
v-cloak     v-cloak结合CSS属性，来实现Vue未渲染时，元素不显示，当渲染时再显示
            <style>
                [v-cloak]{    // 属性选择器
                    display: none;
                }
            </style>
            <h1 v-cloak>{{name}}</h1>
v-once      此处n只会变化一次，n=1
            <h2 v-once>initial n: {{n}}</h2>
v-pre       跳过所在节点的编译过程，达到快速编译
            <h2 v-pre>fuck you</h2>



一些实例应用：

列表过滤  模糊搜索  用计算属性定义一个属性指向原来的内容属性，通过数组的方法来实现
computed: {
    bakPersons: {
        get() {    // 必须是函数表达式
            return this.persons.filter(p => p.name.includes(this.search))
        }
    }
}

列表的排序 通过数组的方法来实现 sortType作为不同排序的index
computed: {
    bakPersons(){
        const t = this.persons.filter(p => p.name.includes(this.search))
        // 操作数组中的对象时的sort
        if (this.sortType == 2) return t.sort((a, b) => a.age - b.age)
        else if (this.sortType == 1) return t.sort((a, b) => b.age - a.age)
        else return t
    }                
}

自定义指令
下面分别是 v-big v-fbind，也就是只要用 - 号后面那个当作属性名就可以
v-big-number，属性就需要用"big-number"
directives:{    // 这个单词就是指令的意思
    // 第一种写法
    big(element, binding) {
        // console.log(e);
        element.textContent = binding.value * 10
    },
    // 第二种写法
    fbind: {
        // 指令与元素成功绑定时
        bind(element, binding){
            element.value = binding.value
        },
        // 元素被插入页面时
        inserted(element, binding){
            element.focus()
        },
        // 指令所在模板被重新解析时
        update(element, binding){
            element.value = binding.value
        }
    }
}


生命周期钩子：

// 用于在创建VM的时候绑定 全局事件总线 axios 
beforeCreate () {
    console.log('beforeCreate', this);
    // debugger
},
created () {
    // 数据监视和数据代理上线
    // 挂到el配置的HTML元素上
},
beforeMount () {
    
},

// 可用于监听全局事件，达到数据传递的目的
mounted() {
    // ajax请求，启动定时器，绑定自定义事件，订阅消息
},
beforeUpdate () {
    
},
updated () {
    
},
beforeDestroy () {
    // 清除定时器，解绑自定义事件，取消订阅消息
    clearTimeout(XXX);
    clearInterval(XXX);
    console.log('beforeDestroy');
},
destroyed () {
    console.log('destroyed');
},

// 激活和失活的生命周期，可以避免路由缓存时，定时器/不需要的内容也缓存的情况，可以及时清理
activated () {
  this.timer = setInterval(()=>{
    console.log('fuck');
    this.opacity = this.opacity < 0 ? 1 : this.opacity -= 0.1
  }, 200)
},
deactivated () {
  clearInterval(this.timer)
}


// 在DOM元挂载完之后执行，可与ref配合，实现input框在页面重新加载渲染时的focus
this.$nextTick(()=>{})






=====================Vue/cli脚手架====================

main.js:
// 引入Vue
import Vue from 'vue'
// 所有组件的父组件
import App from './App.vue'

new Vue({
  el: '#app',
  render: h => h(App),
})
或者

// 创建Vue实例对象
new Vue({
  // 将app组件放入容器中
  // 这里面h实际上是 createElement
  // render会调用vue的模板解析器，为了不造成代码的冗余，从众多js中进行了分离
  // render: h => h(App),
  render: function (a) { 
    // console.log(App);
    // console.log(typeof App);
    return a(App) 
  },  // 效果是一样的
  // VM对象挂载在一个index.html中的id为app的元素上
}).$mount('#app')   // 这个就相当于el: "#app"


XXX.vue:
<template>
    <div class="container">

    </div>
</template>

<script>
import XXX from 'XXX'
export default {
    name: 'App',
    components: {},
    data(){
        return{}
    },
    methods: {},
    computed: {},
    watch: {},
    // 各种生命周期钩子
    props: [],

</script>

<style scoped>

</style>


ref 给元素或者组件打上标记，再通过this.$refs.btn就能获取这个元素或者组件，使用其身上的所有方法和属性
其实更正确的是代替js中获取DOM元素的操作来获取DOM元素


可用来标记input,获取组件或者元素,进行focus
<button ref="btn">previous</button>
应用在组件上时，可以获取其所以的数据和方法
<School ref="sch"></School>


组件通信 组件间通信 props 自定义事件 ref给子组件标记 全局事件总线 作用域插槽 

props
可以在父组件中给子组件添加额外的属性，然后在子组件中通过props接收收到的参数
通过给age绑定，使age转为number
<Student name="fuck" :age="11" gender="male"></Student>

minxin，感觉了解一下就好，用到了再查一下

插件
在main.js中引入，import XXX from 'XXX'
然后 Vue.use(XXX)

axios:
在main.js中引入，加入到Vue的原型上
import axios from 'axios'
new Vue({
  el: '#app',
  render: h => h(App),
  beforeCreate () {
    Vue.prototype.$bus = this
    Vue.prototype.$axios = axios    // 

  }
})

// get后面的url不能加协议、域名、端口号，不然请求不走代理
this.$axios.get('/api/list').then((result) => {
  console.log(result.data);
}).catch((err) => {
  console.log(err.message);
});


vue inspect > output.js    // 注意要用管理员身份，将vue的一些配置打印出来

CORS 跨域访问问题
从浏览器位置发送请求，其origin就是当前网页的 协议+域名+端口
这种情况是浏览器向服务器发送请求时，因为 协议 域名 端口 有一个不同了，所以被”策略“判定为了跨域
1.CORS解决跨域，后台配置响应头的方式来解决，亲测有效
2.jsonp
3.代理服务器，服务器之前不会有跨域问题，所以只要代理服务器的协议+域名+端口与浏览器一致就可以了，在vue.config.js中配置
module.exports = {
    devServer: {
        // 开启代理服务器，端口要配置为要请求的服务器的端口号
        // proxy: 'http://localhost:5001'
        proxy: {
            '/': {
                target: 'http://localhost:5001',
                changeOrigin: true,
                // pathRewrite: {"^/api": ""}    // 给服务器的时候，会把/api前缀给干掉
            }
        }
    },
}


插槽slot：
默认插槽：
通过父组件中在组件标签中间放入HTML结构，子组件声明<slot></slot>
<Category title="fuck">
 <ul v-for="(i, index) of fuck" :key="index">
   <li>{{ i }}</li>
</ul>
</Category>

具名插槽：
在被插入插槽的标签上增加slot属性对应插槽的slot属性，来实现精准的控制
<Category title="fuck">
<ul v-for="(i, index) of fuck" :key="index" slot="center">
  <li>{{ i }}</li>
</ul>
<div class="footer" slot="footer">
  <a href="javascript:;">fuck shit</a>
</div>
</Category>

<slot name="center"></slot>
<slot name="footer"></slot>

作用域插槽，结合template使用
<Category title="fuck">
  <template scope="fuck">
    <ul>
      <li v-for="(i, index) of fuck.fuck" :key="index">{{ i }}</li>
    </ul>
  </template>
  <div class="footer">
    <a href="javascript:;">fuck shit</a>
  </div>
</Category>


Vuex：
//main.js引入store
import store from './store/index.js'

new Vue({
  el: '#app',
  store, // store属性
  render: h => h(App),
  beforeCreate () {
    Vue.prototype.$bus = this
    Vue.prototype.$axios = axios
  }
})

store/index.js中
// vuex中的store
import Vuex from 'vuex'

import Vue from 'vue'

import {nanoid} from 'nanoid'

// 应用Vuex插件
Vue.use(Vuex)

// actions 响应组件中的动作，预先做一些数据或者东西的准备
const actions = {
        plus: function(context, val){
        context.commit('plus', val)
    },

}

// mutations 操作数据
const mutations = {
    plus: (state, val) => {
        state.num += val
    },
}

// state 存储数据
const state = {
    num: 0,
    personList: [
        {id: 1, name: 'fuck'},
        {id: 2, name: 'shit'},
    ],
}

// 这个就是state_2.0，可以对state中的数据做其他操作
const getters = {
    bigSum(state){
        return state.num * 10
    }
}

// 创建并暴露store
export default new Vuex.Store({
    actions,
    mutations,
    state,
    getters,
})

然后在需要用vuex的组件中，通过
this.$store.dispatch('XXX', this.step) 把数据给 actions
this.$store.commit('XXX', this.step)   把数据给 mutations

DOM元素中这么接收
<h2>num: {{ $store.state.num }}</h2>
<h2>num: {{ $store.getters.bigSum }}</h2>





路由：非常重要
// main.js中引入router
import VueRouter from 'vue-router'
import router from './router/index.js'

Vue.use(VueRouter)

new Vue({
  el: '#app',
  render: h => h(App),
  router,  // 这里确实要写router，也就是路由器，不能是route路由
  beforeCreate () {
    Vue.prototype.$bus = this
    Vue.prototype.$axios = axios
  }
})

router-link配置导航
to指示导航项，地址栏也会变
<router-link to="/about">About</router-link

<!-- 组件展示的位置 -->
<router-view></router-view>

./router/index.js中先引入需要路由的各种组件
import VueRouter from 'vue-router'
配置路由的信息
export default new VueRouter({
    // 注意这里必须是routes，不能拼错
    routes: [
        name: '/fuck'    // 注意只有第一层有/，下面的都不允许有/
        path: 'message',
        component: Message,
        meta: {flag: true, XXX: XXX} // 可以自己随意配置一些元信息，搞个flag用来判断啥的
        children: [
            {
                path: 'details/:id/:title',  //  前面不能有 /，如果用params的方式传递参数，需要使用这种方式
                component: MessageContent,
            },
        ]
    ]
})


通过路由传递数据
query参数
第一种写法
<router-link :to="`/home/message/details?id=${m.id}&title=${m.title}`">{{ m.title }}</router-link>

第二种写法
<router-link :to="{
    path: '/home/message/details',
    name: 'fuck', // 也可以不写path，用名称，这个名称和./router/index.js中配置的路由名称要一致
    query: {
        id: m.id,
        title: m.title
    }
}">
    {{ m.title }}
</router-link>

然后在被路由加载出来的组件中这样获取数据
<li>id: {{ $route.query.id }}</li>

params参数：
./router/index.js中需要配置占位符
name: 'xiangqing',
path: 'details/:id/:title', // 不然不知道哪个是哪个
component: MessageContent,

第一种写法
<router-link :to="`/home/message/details/${m.id}/${m.title}`">{{ m.title }}</router-link>
第二种写法
<router-link :to="{
    // params参数不能写path，只能写name
    name: 'xiangqing',  // 可以节省点，但是感觉最好不要省
    params: {
        id: m.id,
        title: m.title
    }
}">
    {{ m.title }}
</router-link>


路由的props配置：
name: 'xiangqing',
path: 'details/:id/:title',
component: MessageContent,
// 对象写法，所有的属性都会以props的形式传给MessageContent
// props: {a: 1,b: 'fuckyou'}

// 布尔值写法
// 若为true，就会把所有收到的params参数以props的形式传给MessageContent，也就是路径上的那个id和title
// props: true

// 函数写法
props($route){
    return {id: $route.params.id, title: $route.params.title}
}
这样在组件中就可以用props来接收了 props: ['id', 'title'] 


编程式路由导航，相当重要：
methods: {
    // 原来会传入这个m？好神奇
    push(m){
        // 编程式跳转，相当重要
        this.$router.push({    // 可以回退的查看
            name: 'xiangqing',  // 这个name就是./router/index.js中配置的
            params: {
                id: m.id,
                title: m.title,
            }
        })
    },
    replace(m){
        this.$router.replace({
            name: 'xiangqing',  // 不可以回退的查看
            params: {
                id: m.id,
                title: m.title,
            }
        })
    }
}

缓存路由组件：可以使组件中输入的数据什么的得到缓存，切出去切回来还有
<!-- 路由缓存，include输入组件名称，也就是New.vue中配置的name属性 -->
<!-- 单个的情况 -->
<!-- <keep-alive include="News"> -->
<!-- 多个的情况，不写include就是全都缓存 -->
<keep-alive :include="['News', 'Message']">
  <router-view></router-view>
</keep-alive>





全局路由守卫，感觉挺重要
首先不能直接export default，需要把router对象拿出来
const router = new VueRouter({})

// 全局前置路由守卫
// 初始化和在每一次路由切换之前被调用
// to: 目的地的路由，from：从哪个路由来，next() 允许放行
router.beforeEach((to, from, next) => {
    // 路由的meta属性可以传入一个对象，里面可以配置自己想配置的标签或者值
    if (to.meta.isAuth) {
        if (to.path == '/home/news' || to.name == 'xiaoxi') {
            if (localStorage.getItem('school') == 'fuck') {    
                next()
            }
        }
    } else {
        next()
    }
    
})

// 全局后置路由守卫
// 每一次路由切换之后被调用
router.afterEach((to, from)=>{
    if (to.meta.isTitle) document.title=to.name
    else document.title='shit'
})

// 独享路由守卫，写在routes的配置项之中的
name: 'xinwen',
path: 'news',
component: News,
meta: { isAuth: true },
// 独享路由守卫只有前置没有后置守卫
beforeEnter: (to, from, next) => {
    if (localStorage.getItem('school') == 'fuck') next()
}


组件内路由守卫
// 根据路由规则，进入该组件时
beforeRouteEnter(to, from, next){
  // console.log(to, from);
  next()
},
// 根据路由规则，离开该组件时
beforeRouteLeave(to, from, next){
  // console.log(to, from);
  next()
},

hash和history模式：
const router = new VueRouter({
    // 默认hash模式，会加上路径上会有/#/,#号后面的标记都不会被认为是请求时的路径而加到请求的路径中
    // history，不会有/#/，会有地址找不到的风险，需要服务器端配合，识别那些是静态组件，不需要跳转
    // mode: 'hash',
    mode: 'history',
})


npm run serve    // 启动Vue项目
npm run build    // 打包
用node搭建简易服务器：
在某个文件夹中，npm init，创建基本的运行环境
创建static文件夹，将打包的文件放入其中
创建server.js，内容：
---------------------------------------------------------------------------
//导入express
const express = require('express')
const history = require('connect-history-api-fallback')
//创建web服务器
const app=express()

app.use(history())
app.use(express.static(__dirname + "/static"))

app.get('/person', (req, res) => {
    res.send({
        name: 'fuck',
        age: 22
    })
})

app.listen(5005,(err)=>{
    if(!err) console.log('OK');
})
---------------------------------------------------------------------------

node server    // 启动服务
应该默认是localhost然后加上那个端口号访问



---------------------------------------------------------------------------


ECharts





































---------------------------------------------------------------------------


Vue开发规范 一些规范

增删改查方法命名
add / update / delete / detail / get 

附： 函数方法常用的动词: 
get 获取/set 设置, 
add 增加/remove 删除, 
create 创建/destory 销毁, 
start 启动/stop 停止, 
open 打开/close 关闭, 
read 读取/write 写入, 
load 载入/save 保存,
begin 开始/end 结束, 
backup 备份/restore 恢复,
import 导入/export 导出, 
split 分割/merge 合并,
inject 注入/extract 提取,
attach 附着/detach 脱离, 
bind 绑定/separate 分离, 
view 查看/browse 浏览, 
edit 编辑/modify 修改,
select 选取/mark 标记, 
copy 复制/paste 粘贴,
undo 撤销/redo 重做, 
insert 插入/delete 移除,
add 加入/append 添加, 
clean 清理/clear 清除,
index 索引/sort 排序,
find 查找/search 搜索, 
increase 增加/decrease 减少, 
play 播放/pause 暂停, 
launch 启动/run 运行, 
compile 编译/execute 执行, 
debug 调试/trace 跟踪, 
observe 观察/listen 监听,
build 构建/publish 发布,
input 输入/output 输出,
encode 编码/decode 解码, 
encrypt 加密/decrypt 解密, 
compress 压缩/decompress 解压缩, 
pack 打包/unpack 解包,
parse 解析/emit 生成,
connect 连接/disconnect 断开,
send 发送/receive 接收, 
download 下载/upload 上传, 
refresh 刷新/synchronize 同步,
update 更新/revert 复原, 
lock 锁定/unlock 解锁, 
check out 签出/check in 签入, 
submit 提交/commit 交付, 
push 推/pull 拉,
expand 展开/collapse 折叠, 
enter 进入/exit 退出,
abort 放弃/quit 离开, 
obsolete 废弃/deprecate 废旧, 
collect 收集/aggregate 聚集


script 标签内部结构顺序
components > props > data > computed > watch > filter > 钩子函数（钩子函数按其执行顺序） > methods


6) 组件的 data 必须是一个函数
当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。因为如果直接是一个对象的话，子组件之间的属性值会互相影响。

export default {
  data () {
    return {
      name: 'jack'
    }
  }
}


7) Prop 定义应该尽量详细
必须使用 camelCase 驼峰命名
必须指定类型
必须加上注释，表明其含义
必须加上 required 或者 default，两者二选其一
如果有业务需要，必须加上 validator 验证

 props: {
  // 组件状态，用于控制组件的颜色
   status: {
     type: String,
     required: true,
     validator: function (value) {
       return [
         'succ',
         'info',
         'error'
       ].indexOf(value) !== -1
     }
   },
    // 用户级别，用于显示皇冠个数
   userLevel：{
      type: String,
      required: true
   }
}


页面跳转数据传递使用路由参数
页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。

let id = ' 123';
this.$router.push({ name: 'userCenter', query: { id: id } });

使用路由懒加载（延迟加载）机制
{
    path: '/uploadAttachment',
    name: 'uploadAttachment',
    meta: {
      title: '上传附件'
    },
    component: () => import('@/view/components/uploadAttachment/index.vue')
  },






3) router 中的命名规范
path、childrenPoints 命名规范采用kebab-case命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是kebab-case，这样很方便找到对应的文件）

name 命名规范采用KebabCase命名规范且和component组件名保持一致！（因为要保持 keep-alive 特性， keep-alive 按照component的name进行缓存，所以两者必须高度保持一致）

// 动态加载
export const reload = [
  {
    path: '/reload',
    name: 'reload',
    component: Main,
    meta: {
      title: '动态加载',
      icon: 'icon iconfont'
    },

    children: [
      {
        path: '/reload/smart-reload-list',
        name: 'SmartReloadList',
        meta: {
          title: 'SmartReload',
          childrenPoints: [
            {
              title: '查询',
              name: 'smart-reload-search'
            },
            {
              title: '执行reload',
              name: 'smart-reload-update'
            },
            {
              title: '查看执行结果',
              name: 'smart-reload-result'
            }
          ]
        },
        component: () =>
          import('@/views/reload/smart-reload/smart-reload-list.vue')
      }
    ]
  }
];


4) router 中的 path 命名规范  有道理啊
path除了采用kebab-case命名规范以外，必须以 / 开头，即使是children里的path也要以 / 开头。如下示例


经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件



{
    path: '/file',
    name: 'File',
    component: Main,
    meta: {
      title: '文件服务',
      icon: 'ios-cloud-upload'
    },
    children: [
      {
        path: '/file/file-list',
        name: 'FileList',
        component: () => import('@/views/file/file-list.vue')
      },
      {
        path: '/file/file-add',
        name: 'FileAdd',
        component: () => import('@/views/file/file-add.vue')
      },
      {
        path: '/file/file-update',
        name: 'FileUpdate',
        component: () => import('@/views/file/file-update.vue')
      }
    ]
  }


vue 项目中的所有命名一定要与后端命名统一。

比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privilege 单词！


使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。

目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。

src                                  源码目录
|-- api                              所有api接口
|-- assets                           静态资源，images, icons, styles等
|-- components                       公用组件
|-- config                           配置信息
|-- constants                        常量信息，项目所有Enum, 全局常量等
|-- directives                       自定义指令
|-- filters                          过滤器，全局工具
|-- datas                            模拟数据，临时存放
|-- lib                              外部引用的插件存放及修改文件
|-- mock                             模拟接口，临时存放
|-- plugins                          插件，全局使用
|-- router                           路由，统一管理
|-- store                            vuex, 统一管理
|-- themes                           “自定义样式”主题
|-- views                            视图目录
|   |-- role                                 role模块名
|   |-- |-- role-list.vue                    role列表页面
|   |-- |-- role-add.vue                     role新建页面
|   |-- |-- role-update.vue                  role更新页面
|   |-- |-- index.less                       role模块样式
|   |-- |-- components                       role模块通用组件文件夹
|   |-- employee                             employee模块


1) api 目录
* 文件、变量命名要与后端保持一致。
* 此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。
* api 中的方法名字要与后端 api url 尽量保持语义高度一致性。
* 对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。


正例：

后端 url： EmployeeController.java

/employee/add
/employee/delete/{id}
/employee/update

前端： employee.js

// 添加员工
addEmployee: (data) => {
  return postAxios('/employee/add', data)
},
// 更新员工信息
updateEmployee: (data) => {
  return postAxios('/employee/update', data)
},
  // 删除员工
deleteEmployee: (employeeId) => {
  return postAxios('/employee/delete/' + employeeId)
},


2) assets 目录
assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case

|assets
|-- icons
|-- images
|   |-- background-color.png
|   |-- upload-header.png
|-- styles

3) components 目录
此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase

|components
|-- error-log
|   |-- index.vue
|   |-- index.less
|-- markdown-editor
|   |-- index.vue
|   |-- index.js
|-- kebab-case


4) constants 目录
此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件

(https://www.npmjs.com/package/vue-enum)

|constants
|-- index.js
|-- role.js
|-- employee.js


export const EMPLOYEE_STATUS = {
  NORMAL: {
    value: 1,
    desc: '正常'
  },
  DISABLED: {
    value: 1,
    desc: '禁用'
  },
  DELETED: {
    value: 2,
    desc: '已删除'
  }
};

export const EMPLOYEE_ACCOUNT_TYPE = {
  QQ: {
    value: 1,
    desc: 'QQ登录'
  },
  WECHAT: {
    value: 2,
    desc: '微信登录'
  },
  DINGDING: {
    value: 3,
    desc: '钉钉登录'
  },
  USERNAME: {
    value: 4,
    desc: '用户名密码登录'
  }
};

export default {
  EMPLOYEE_STATUS,
  EMPLOYEE_ACCOUNT_TYPE
};


5) router 与 store 目录
这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。

router 尽量按照 views 中的结构保持一致

store 按照业务进行拆分不同的 js 文件


6) views 目录
命名要与后端、router、api 等保持一致
components 中组件要使用 PascalCase 规则

|-- views                                    视图目录
|   |-- role                                 role模块名
|   |   |-- role-list.vue                    role列表页面
|   |   |-- role-add.vue                     role新建页面
|   |   |-- role-update.vue                  role更新页面
|   |   |-- index.less                      role模块样式
|   |   |-- components                      role模块通用组件文件夹
|   |   |   |-- role-header.vue             role头部组件
|   |   |   |-- role-modal.vue              role弹出框组件
|   |-- employee                            employee模块
|   |--behavior -log                        行为日志log模块
|   |-- code-generator                      代码生成器模块



注释说明

整理必须加注释的地方

* 公共组件使用说明
* api 目录的接口 js 文件必须加注释
* store 中的 state, mutation, action 等必须加注释
* vue 文件中的 template 必须加注释，若文件较大添加 start end 注释
* vue 文件的 methods，每个 method 必须添加注释
* vue 文件的 data, 非常见单词要加注释

其他

1) 尽量不要手动操作 DOM
因使用 vue 框架，所以在项目开发中尽量使用 vue 的"数据驱动"更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。

2) 删除无用代码
因使用了 git/svn 等代码版本工具，对于无用代码必须"及时删除"，例如：一些调试的 console 语句、无用的弃用功能代码。


=======================小小的心得体会=======================

模块化开发、接口化的开发

element-ui 的东西

节流、防抖 都是 定时器+闭包的原理

css玩儿简单的、固定的、组件内的样式，js玩儿复杂的，多组件效果联动、区别的样式

优化：
    事件委派
    减少请求    缓存 将数据交给vuex管理 只在App.vue的 mounted 阶段进行请求


刷新页面会导致组件的重新创建和挂载。并且路由无论如何都会重新解析一次


loading可以写在接口的请求函数里，用普通函数，this.loading=true 请求数据 this.loading=false，因为普通函数的this是调用者的this，这样就可以了


打包流程

业务的话最重要的还是数据结构和算法的定义

权限管理 Vue的
































