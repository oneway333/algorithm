====================================一些面试题====================================

* es5和es6

es6新增的
let const es6
()=>{} 箭头函数
模板字符串 `${vary}`
解构赋值  let {a, b} = obj  let [a, b] = arr
for of
Set Map
import export
set数据结构
...展开运算符
修饰器 @decorator 函数
class类
async await promise 、promise异步编程解决方案
Symbol 基本类型
Proxy 代理 解决跨域问题？


* promise的几种状态，进入catch的时机

- pending     等待
- fulfilled   完成
- reject      拒绝

状态不可逆
pending -> fulfilled 成功
pending -> reject 异常 catch

const promise = new Promise((resolve, reject) => {
    console.log(1)
    resolve() // 异步的，不会阻塞运行
    console.log(2)
})

promise.then(()=>{
    console.log(3)
})

console.log(4)

因为resolve()运行完成，then才会执行

运行结果为1 2 4 3


* 手写 promise

class Promise {
    constructor(executer) {
        this.status = 'pending' 
        this.value = undefined
        this.reason = undefined
        let resolveFn = (value) => {
            if(this.status === 'pending'){
                this.status = 'resolve'
                this.value = value
            }
        }
        let rejectFn = (reason) => {
            if(this.status === 'pending'){
                this.status = 'reject'
                this.reason = reason
            }
        }
        
        try {
            executer(resolveFn, rejectFn)
        } catch (e) {
            rejectFn(e)
        }
        
        
    }

    // 类里面都是属性，没有什么let var的
    then(onFulfilled, onRejected) {
        if (this.status === 'resolve') onFulfilled(this.value)
        if (this.status === 'reject')  onRejected(this.reason)
    }
}


* 模块化开发

export 三种
import 三种


* 字符串方法

includes 用来检查字符串中是否包含某个内容
indexof  默认-1
endsWith startsWith


* 数据方法

1. Array.from(set/map)
2. Array.of() 将一组值转成数组
3. Array.fill()
4. Array.find() Array.findIndex()
5. entries() keys() values()
6. includes()
7. flat(n) 数组扁平化

[1, [2, [3]]].flat(Infinity)  // [1, 2, 3]

8. flatMap() 只能展开一层数组

[1, 2, 3, 4].flatMap(x => [[x * 2]])    // [[2], [4], [6], [8]]


* 对象拓展的属性

- Object.keys()
- Reflect.ownKeys(obj)
- Object.is()
- Object.assign(target, obj1, obj2)    对象复制，重复的后面覆盖前面


* Generator

异步编程解决方案
迭代器生成函数 调用并不会立即执行 返回一个迭代器 可以进行异步调用
支持挂起操作

- function* testGenerator(){}
- yield 定义不同的内部状态

function* testGenerator() {
    yield 'a';
    yield 'b';
    yield 'c';
}

var g = testGenerator()
g.next()  // 返回值 {value: 'a', done: false} next执行函数内部状态
g.next()  // 返回值 {value: 'b', done: false}
g.next()  // 返回值 {value: 'c', done: true}


* ES6模块与CommonJS 模块的相同点和区别

相同点：
- 对引入对象进行赋值 即使得对象内部属性的值改变

区别：
- CommonJS 通过require引入  ES6 通过import引入


* 从输入url，到页面得画面展示的过程

- 输入url
- 浏览器缓存 - 系统缓存 - 浏览器缓存 有缓存 显示页面内容
- http 请求前 dns ip地址
- tcp连接 三次握手
- 握手成功 浏览器发送http请求 请求数据包
- 服务器收到请求 返回数据到浏览器
- http响应
- 读取页面内容 渲染 解析html源码
- 生成dom树 解析 css样式 js交互 渲染显示页面


* 什么是虚拟 DOM 为什么需要虚拟 DOM

js用对象的属性描述节点 映射到真是环境

虚拟DOM 节点 与真实DOM属性一一对应

dom操作引起性能问题
虚拟DOM通过虚拟节点 进行diff算法，减少页面无谓的计算
支持跨平台能力


* Promise 中的值穿透

.then .catch 期望是函数 如果传入非函数则会发生值穿透

Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log)  // 打印出1

发生了值穿透
promise 的data 就会保存上一个promise.data


* JS脚本延迟加载的方式

延迟加载 等页面加载完成后再加载 JS，有助于提升页面的加载速度

1. defer 在 script 上加defer 同步加载 不会阻塞页面加载过程
2. async 异步加载 不会阻塞页面加载过程
3. 动态创建DOM方式：对文档的加载事件进行监听，当文档加载完成后再动态的创建 script标签来引入js脚本
4. setTimeout 延迟加载js脚本
5. 让js最后加载


* 异步编程有哪些实现方式：

异步机制
1. 回调函数：回调地狱，代码耦合度高、不利于代码维护
2. Promise：链式调用
3. generator：同步顺序书写
4. async  generator promise 自动执行的语法糖 内部自带执行器 await 等待Promise变成resolve 异步逻辑转化为同步顺序 自动执行


* pnpm

包管理器
优势：
- 包安装速度极快
- 磁盘空间利用高效


* 怎么理解Promise

异步编程解决方案 对象 获取异步操作信息 避免回调地狱
一个容器，保存某个未来才会结束的事件

见上面的自己实现一个promise，注意回调函数一开始进去的只是形参，回调函数只是一段逻辑。只是放入对象之后，对象实际上也向回调函数中传递了参数，所以至始至终都是修改的对象的内部数据。

let request = ()=>{}

function XXX1(request) {
    data = request()
    return data
}

function XXX2(XXX1()){
    data2 = XXX1()
    return data2
}

function XXX3(XXX2()){
    data3 = XXX2()
    return data3
}

xxx3(xxx2(xxx1(request)))   这很地狱？


状态：
1. pending 等待
2. resolved 已完成
3. rejected 已拒绝

两个过程
1. pending -> fulfilled resolved 已完成
2. pending -> rejected  rejected 已拒绝

状态不可逆


特点：
1.对象状态不受外界影响    封装起来了，不给其他人看到
2.只有异步操作的结果 可以决定当前是哪一种状态

缺点
无法取消 promise

1.promise对象是异步编程解决方案，一个构造函数 接受一个函数作为参数 返回promise实例
2.三个状态：

注意：
构造promise的时候，构造函数内部的代码立即执行


* ES6 module 模块化 好

* 函数式编程

- 命令式编程 
- 声明式编程
- 函数式编程 强调结果而非过程

* CSR 和 SSR

- CSR 客户端渲染
- SSR js文件大，加载慢，首屏白屏 解决？
   服务端渲染 服务端直接生成 html




































========================================================================


编写位置 
变量声明
常量声明
类型检查 typeof
使用反单引号`来表示"模板字符串“   `${变量}`

JS中原始值一共有七种
1.Number
2.BigInt
3.77
4.Boolean
5.Null
6.Undefined
7.Symbol

...展开运算符
可以复制，做函数形参
arr1 = [...arr2]
arr = [...obj]
arr = [...map]

对象的复制
Object.assign(destination, obj)
window.structuredClone()    由于是window开头的，可以不写


数据方法
Array.isArray()    用来检查一个对象是否是数组
arr = Array.from(map) // [["name","孙悟空"],["age",18]]
at()               可以根据索引获取数组中的指定元素   at可以接收负索引作为参数
concat()           用来连接两个或多个数组  非破坏性方法，不会影响原数组，而是返回一个新的数组
indexof()          获取元素在数组中第一次出现的索引  参数： 1. 要查询的元素  2. 查询的起始位置
lastindexof()       - 获取元素在数组中最后一次出现的位置，也有两个参数
join()          数组转字符串
slice()         切片，传一个开始一个结束位置，也可以用来复制 arr1 = arr.slice()
push()         末尾添加一个或多个元素
pop()          删除并返回最后一个元素
unshift()      开头添加一个或多个元素
shift()        删除并返回开头一个元素
splice()       可以删除、插入、替换数组中的元素
参数：
1. 删除的起始位置
2. 删除的数量
3. 要插入的元素

some()         传入一个回调函数,遍历每个项目,并返回回调函数的返回值
attrValueList.some(item => {
// 防止和新增的自己对比
    if (row !== item) {
  return row.valueName === item.valueName
}


reverse()     反转数组
sort()        arr.sort((a, b)=> a - b) 升序   arr.sort((a, b)=> b - a) 降序
forEach()     遍历
arr.forEach((element, index, array) => {
    console.log(array)
})

filter(()=>{})      将数组中符合条件(true)的元素保存到一个"新数组"中返回
arrNew = arr.filter((a)=>{某些满足条件的元素，最后记得return true/false，但是如果只有一行就默认return表达式的返回值})

map()       根据当前数组生成一个新数组，而forEach仅仅遍历
result = arr.map((ele) => ele * 2)
result = arr.map((ele) => "<li>" + ele + "</li>")

reduce()    可以用来将一个数组中的所有元素"整合"为一个值
参数：
  1. 回调函数，通过回调函数来指定合并的规则
  2. 可选参数，初始
result = arr.reduce((a, b) => a + b, 10)



Map    散列表
创建：
    new Map()

属性和方法：
map.size() 获取map中键值对的数量
map.set(key, value) 向map中添加键值对
map.get(key) 根据"key获取值"
map.delete(key) 删除指定数据
map.has(key) 检查map中是否包含指定键
map.clear() 删除全部的键值对
map.forEach((key, value)=>{
                console.log(key, value)
            })
            

Set    集合
创建
    - new Set()
    - new Set([...])

方法
    size 获取数量
    add() 添加元素
    has() 检查元素
    delete() 删除元素
    

Math    数学工具类
- 常量：
    Math.PI 圆周率
- 方法：
    Math.abs() 求一个数的绝对值
    Math.min() 求多个值中的最小值
    Math.max() 求多个值中的最大值
    Math.pow() 求x的y次幂
    Math.sqrt() 求一个数的平方根   可以用 x**x替代
    Math.floor() 向下取整
    Math.ceil() 向上取整
    Math.round() 四舍五入取整
    Math.trunc() 直接去除小数位
    Math.random() 生成一个0-1之间的随机数


Date    日期类
创建    new Date()
getFullYear() 获取4位年份
getMonth() 返当前日期的月份（0-11）
getDate() 返回当前是几日
getDay() 返回当前日期是周几（0-6） 0表示周日
......
getTime() 返回当前日期对象的时间戳
    时间戳：自1970年1月1日0时0分0秒到当前时间所经历的毫秒数
    计算机底层存储时间时，使用都是时间戳
Date.now() 获取当前的时间戳


字符串:
串其本质就是一个字符数组
串的很多方法都和数组是非常类似的属性和方法：
length 获取字符串的长度
字符串[索引] 获取指定位置的字符
str.at() （实验方法）
    - 根据索引获取字符，可以接受负索引
str.charAt()
    - 根据索引获取字符
str.concat()
    - 用来连接两个或多个字符串
str.includes()
    - 用来检查字符串中是否包含某个内容
        有返回true
        没有返回false
str.indexOf()
str.lastIndexOf()
    - 查询字符串中是否包含某个内容
str.startsWith()
    - 检查一个字符串是否以指定内容开头
str.endsWith()
    - 检查一个字符串是否以指定内容结尾
str.padStart()
str.padEnd()
    - 通过添加指定的内容，使字符串保持某个长度
str.replace()
    - 使用一个新字符串替换一个指定内容  
str.replaceAll()    
    - 使用一个新字符串替换所有指定内容
str.slice()
    - 对字符串进行切片
str.substring()
    - 截取字符串
str.split()
    - 用来将一个字符串拆分为一个数组
str.toLowerCase()
    - 将字符串转换为小写
str.toUpperCase()
    - 将字符串转换为大写
str.trim()
    - 去除前后空格
str.trimStart()
    - 去除开始空格
str.trimEnd()
    - 去除结束空格





字符串方法 XX.toString()  String(XXX) window下的方法
数值的方法 Number(XXX), parseInt(XXX), parseFloat(XXX)
布尔值的方法 Boolean(XXX)
运算符
** 幂运算 可以实现根号 XXX**.5
??=-空赋值 只有当变量的值为null或undefined时才会对变量进行赋值
一元的±  +b 相当于 b = Number(b)
== 它会将其转换为相同的类型（通常转换为数值）然后再比较
=== 它不会进行自动的类型转换，如果两个值的类型不同直接返回false

对象 注意可以用[] 比如 XXX[XXX] = XXX，属性就是[]里面的XXX
枚举属性 for-in
创建对象最好用 const 修饰，避免被修改
对象里面可以写字面量 函数 其他对象

函数的三种创建方法 
function <name>(){}
let <name> = function(){}
let <name> = ()=>{}
函数的返回值 箭头函数的返回值 return XXX 
立即执行函数 (function(){})() (function(){}())
函数中的this 箭头函数中的this，与调用方式无关，this指向外层作用域的函数的this。注意外层作用域中的外层指的是函数外层
严格模式

面向对象
构造方法
静态方法 通过 <class name>.方法名 的方式
多态 同一个函数 根据传入的对象不同实现不同的效果，不是用if else 而是直接调用对象里面的方法
继承 当重写父类构造方法时，构造方法第一行要写super()

原型对象 对象中还有一些内容，会存储到其他的对象里（原型对象） 在对象中会有一个属性用来存储原型对象，这个属性叫做 __proto__
访问原型对象
obj.__proto__, Object.getPrototypeOf(obj)
原型对象中的数据：
1. 对象中的数据（属性、方法等）
2. constructor（对象的构造函数）
原型链
读取对象属性时，会优先对象自身属性，
如果对象中有，则使用，没有则去对象的原型中寻找
如果原型中有，则使用，没有则去原型的原型中寻找
直到找到"Object对象"的原型（Object的原型没有原型（为null））
如果依然没有找到，则返回undefined

所有的同类型对象它们的原型对象都是同一个，也就意味着，同类型对象的原型链是一样的

修改原型
obj.__proto__.xxx = ...
<class name>.prototype.xxx = 

instanceof 自身和原型链 obj instanceof <class name>
in 自身和原型链 <prop name> in obj 
Object.hasOwn(obj, <prop name>) 自身

DOM:

通过document来获取已有的元素节点
document.getElementById()
document.getElementsByClassName()
document.getElementsByTagName()
document.getElementsByName()
document.querySelectorAll()    常用
document.querySelector()    常用
创建
document.createElement()

通过元素节点对象获取其他节点的方法
element.childNodes 获取当前元素的子节点（会包含"空白"的子节点）
element.children 获取当前元素的子元素
element.firstElementChild 获取当前元素的第一个子元素
element.lastElementChild 获取当前元素的最后一个子元素
element.nextElementSibling 获取当前元素的下一个兄弟元素
element.previousElementSibling 获取当前元素的前一个兄弟元素
element.parentNode 获取当前元素的父节点
element.tagName 获取当前元素的标签名    这个好

文本节点 重要的
element.textContent 纯文本，不会带CSS样式
element.innerText   带CSS样式的文本
element.innerHTML 获取或修改元素中的html代码    不建议，会有XSS注入风险

属性节点
方式一：
读取 元素.属性名 
修改 元素.属性名 = 属性值
当属性是class的时候，属性名要变成className

方式二：
读取：元素.getAttribute(属性名)
修改：元素.setAttribute(属性名, 属性值)
删除：元素.removeAttribute(属性名)


事件：
1.可以直接在元素的属性中设置
2.可以通过为元素的"指定属性(element.onclick这样子的)"设置“回调函数”的形式来绑定事件（一个事件只能绑定一个响应函数）
3.可以通过元素addEventListener()方法来绑定事件 btn.addEventListener("click", function(){
    alert("哈哈哈")
})


DOM修改：
appendChild()    给一个节点添加“子节点”
insertAdjacentElement()可以向元素的任意位置添加元素
element.insertAdjacentElement("afterend", element)
element.insertAdjacentElement("afterbegin", element)
element.insertAdjacentElement("beforeend", element)
element.insertAdjacentElement("beforebegin", element)
element.remove() 删除结点

cloneNode()    复制节点，传入true会复制子结点


CSS修改

元素.style.样式名 = 样式值

getComputedStyle() 它会返回一个对象，这个对象中包含了当前元素所有的生效的样式

元素.classList 是一个对象，对象中提供了对当前元素的类的各种操作方法

元素.classList.add() 向元素中添加一个或多个class
元素.classList.remove() 移除元素中的一个或多个class
元素.classList.toggle() 切换元素中的class 切换样式是否生效
元素.classList.replace() 替换class
元素.classList.contains() 检查class


事件对象：

box1.addEventListener("mouesmove", event => {    // event事件对象，回调函数的形参
    // 箭头函数
    console.log(event.clientX, event.clientY)   // this指向window
    box1.textContent = date.toString() + ',' + event.clientX + "," + event.clientY
})


box1.addEventListener("mousemove", function(e){    // 函数表达式的形式
    console.log(e.clientX, e.clientY);
    console.log(this);   // this指向box1
    box1.textContent = e.clientX + ',' + e.clientY
})


event.target 触发事件的对象
event.currentTarget 绑定事件的对象（同this）
event.stopPropagation() 停止事件的传导   不会从里面往外继续事件的触发，俗称冒泡
event.preventDefault() 取消默认行为   比如超链接的跳转


事件的冒泡（bubble） 事件的冒泡就是指事件的向上传导


事件的委派 ”委派就是将本该绑定给多个元素的事件“，统一绑定给document，这样可以降低代码复杂度方便维护。并且通过event.target定位到触发事件的对象，进行精准的控制



BOM： 

window —— 代表浏览器窗口（全局对象）
navigator —— 浏览器的对象（可以用来识别浏览器）
location —— 浏览器的地址栏信息
history —— 浏览器的历史记录（控制浏览器前进后退）
screen —— 屏幕的信息

navigator.userAgent    返回一个用来描述浏览器信息的字符串

location.assign() 跳转到一个新的地址 传入新地址的字符串
location.replace() 跳转到一个新的地址（无法通过回退按钮回退） 传入新地址的字符串
location.reload() 刷新页面，可以传递一个true来强制清缓存刷新
location.href 获取当前地址

history.back()
    - 回退按钮
history.forward()
    - 前进按钮
history.go()
    - 可以向前跳转也可以向后跳转


定时器

setTimeout()  执行一次
    - 参数：
        1. 回调函数（要执行的代码）
        2. 间隔的时间（毫秒） 
    - 关闭定时器
        clearTimeout()

setInterval() (每间隔一段时间代码就会执行一次) 执行多次
    - 参数：
        1. 回调函数（要执行的代码）
        2. 间隔的时间（毫秒）
    - 关闭定时器
        clearInterval()
    但是如果函数执行的速度比较慢，它是”无法确保“每次执行的”间隔都是一样的“
    这个属于一直在跑，但是时间里面会包含等待执行的时间


// 希望可以确保函数每次执行都有相同间隔
console.time("间隔")
setTimeout(function fn() {
    console.timeEnd("间隔")
    alert("哈哈") // 执行完了之后才会再次开启定时，解决了操作慢导致的定时时间不准确的问题

    console.time("间隔")
    // 在setTimeout的回调函数的最后，在调用一个setTimeout
    setTimeout(fn, 2000)
}, 2000)


对象的序列化
JSON.stringify() 可以将一个对象转换为JSON字符串
JSON.parse() 可以将一个JSON格式的字符串转换为JS对象
const str2 = `{"name":"猪八戒","age":28}`   // 对象
const str3 = '{"name":"猪八戒","age":28}'   // 单引号
const str4 = '{"name":"猪八戒","age":28}'   // 单引号
const str5 = "{}"   // 空对象
const str6 = '["hello", true, []]'    // 数组
const str7 = '{"name":"shit", "age": 11, "bool": false, "null": null, "obj":{"name":"fuck"}, "arr": [123, "321", true, null]}'




浏览器本地存储
localStorage.setItem('key', 'value')
localStorage.getItem('key')
localStorage.removeItem('key')
localStorage.clear()

sessionStorage.setItem('key', 'value')
sessionStorage.getItem('key')
sessionStorage.removeItem('key')
sessionStorage.clear()

js文件中的import优先执行，也就是执行import from 'XXX.js'中的XXX.js


==========================AJAX============================

ajax 全名 async javascript and XML(异步JavaScript和XML)

是前后台交互的能力 也就是我们客户端给服务端发送消息的工具，以及接受响应的工具

AJAX 不是新的编程语言，而是一种使用现有标准的新方法。

AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。

默认异步执行机制的功能,AJAX分为同步（async = false）和异步（async = true）


- 什么是同步请求？(false)

 同步请求是指当前发出请求后，浏览器“什么都不能做”，
 必须得等到请求完成返回数据之后，才会执行后续的代码，
 相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。
 也就是说，当JS代码加载到当前AJAX的时候会把页面里"所有的代码停止加载"，页面处于一个假死状态，
 当这个AJAX执行完毕后才会继续运行其他代码页面解除假死状态


- 什么是异步请求？(默认:true)

* 默认异步：异步请求就当发出请求的同时，浏览器可以继续做任何事，
* Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。
* 一般默认值为true，异步。异步请求可以完全不影响用户的体验效果，
* 无论请求的时间长或者短，用户都在专心的操作页面的其他内容，并不会有等待的感觉。


2. AJAX 的优势

* 不需要插件的⽀持，原⽣ js 就可以使用
* 用户体验好（不需要刷新页面就可以更新数据）
* 减轻服务端和带宽的负担
* 缺点：搜索引擎的支持度不够，因为数据都不在页面上，搜索引擎搜索不到


3. AJAX 的操作流程

* 首先通过PHP页面将数据库中的数据取出
* 取出后转成json格式的字符串，后利用ajax把字符串返还给前台
* 再利用json.parse解析通过循环添加到页面上
* 那么反之，前端的数据可以利用ajax提交到后台
* 但是后台是没有办法直接把这些数据插入到数据库中，所以要先提交到PHP页面上
* 最后再由PHP将数据插入到数据库中


4. AJAX 的使用

* 在 js 中有内置的构造函数来创建 ajax 对象

* 创建 ajax 对象以后，我们就使用 ajax 对象的方法去发送请求和接受响应

* Ajax的一个最大的特点是”无需刷新页面“便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。
XMLHttpRequest 对象方法描述

abort()     停止请求
getAllResponseHeaders()      所有响应头
getResponseHeader(<header>)  指定响应头
open(<method>, <url>[, asyncFlag][, username][, password])  建立连接，method get/post/put
send(content)   发送请求
setRequestHeader(<header>, <value>)    设置之前必须先调用open


1.创建一个 ajax 对象

// IE9及以上
const xhr = new XMLHttpRequest()
// IE9以下
const xhr = new ActiveXObject('Mricosoft.XMLHTTP')

上⾯就有了⼀个 ajax 对象
我们就可以使⽤这个 xhr 对象来发送 ajax 请求了


2.配置链接信息

XMLHttpRequest 对象属性描述(用于和服务器交换数据。)

onabort
onerror
onload
onloadend
onloadstart
onprogress
onreadystatechange      状态改变事件触发器
ontimeout
readyState              请求的状态 0=未初始化 1=正在加载 2=已加载 3=交互中 4=完成
response
responseText            响应数据 文本
responseType
responseURL 
responseXML             响应数据 XML 可解析为 DOM对象
status                  HTTP状态码  404 文件未找到  200 成功
statusText              状态文本信息
timeout


//所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。
const xhr = new XMLHttpRequest()
// xhr 对象中的 open 方法是来配置请求信息的
// 第一个参数是本次请求的请求方式 get / post / put / ...
// 第二个参数是本次请求的 url 
// 第三个参数是本次请求是否异步，默认 true 表示异步，false 表示同步
// xhr.open('请求方式', '请求地址', 是否异步)
xhr.open('get', './data.php')

上面的代码执行完毕以后，本次请求的基本配置信息就写完了


3.发送请求

//如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：
const xhr = new XMLHttpRequest()
xhr.open('get', './data.php')
// 使用 xhr 对象中的 send 方法来发送请求
xhr.send()

上面代码是把配置好信息的 ajax 对象发送到服务端

 一个最基本的 ajax 请求就是上面三步 但是光有上面的三个步骤，我们确实能把请求发送到服务端 
 如果服务端正常的话，响应也能回到客户端 但是我们拿不到响应
 如果想要拿到响应，我们需要有两个前提条件
 1. 本次 HTTP 请求是成功的，也就是我们下面要说的 http 状态码为 200 ~ 299
 2. ajax 对象也有自己的状态码，用来表示本次 ajax 请求中各个阶段


5.AJAX 状态码


* ajax 状态码 - xhr.readyState

* 是用来表示一个 ajax 请求的全部过程中的某一个状态

 readyState === 0 : 表示未初始化完成，也就是 open 方法还没有执行 
 readyState === 1 : 表示配置信息已经完成，也就是执行完 open 之后 
 readyState === 2 : 表示 send 方法已经执行完成
 readyState === 3 : 表示正在解析响应内容
 readyState === 4 : 表示响应内容已经解析完毕，可以在客户端使用了

* 这个时候我们就会发现，当一个 ajax 请求的全部过程中，只有当 readyState === 4 的时候，我们才可以正常使用服务端给我们的数据


所以，配合 http 状态码为 200 ~ 299

 一个 ajax 对象中有一个成员叫做 xhr.status
 这个成员就是记录本次请求的 http 状态码的 


readyStateChange

* 在 ajax 对象中有一个事件，叫做 readyStateChange 事件
* 这个事件是专⻔用来监听 ajax 对象的 readyState 值改变的的行为
* 也就是说只要 readyState 的值发生变化了，那么就会触发该事件
* 所以我们就在这个事件中来监听 ajax 的 readyState 是不是到 4 了

const xhr = new XMLHttpRequest() xhr.open('get', './data.php')
xhr.send()
xhr.onreadyStateChange = function () {
// 每次 readyState 改变的时候都会触发该事件
// 我们就在这里判断 readyState 的值是不是到 4
// 并且 http 的状态码是不是 200 ~ 299
if (xhr.readyState === 4 && /^2\d{2|$/.test(xhr.status)) {
// 这里表示验证通过
// 我们就可以获取服务端给我们响应的内容了 }
}


使用 ajax 发送请求时携带参数

* 我们使用 ajax 发送请求也是可以携带参数的
* 参数就是和后台交互的时候给他的一些信息
* 但是携带参数 get 和 post两个方式还是有区别的


GET 还是 POST？

与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。

然而，在以下情况中，请使用 POST 请求：
1. 无法使用缓存文件（更新服务器上的文件或数据库）
2. 向服务器发送大量数据（POST 没有数据量限制）
3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠


发送一个带有参数的 get 请求

get 请求的参数就直接在 url 后面进行拼接就可以

const xhr = new XMLHttpRequest()
// 直接在地址后面加一个 ?，然后以 key=value 的形式传递 // 两个数据之间以 & 分割
xhr.open('get', './data.php?a=100&b=200')
xhr.send()


发送一个带有参数的 post 请求

* post 请求的参数是携带在请求体中的，所以不需要再 url 后面拼接

const xhr = new XMLHttpRequest()
xhr.open('post', './data.php')
// 如果是用 ajax 对象发送 post 请求，必须要先设置一下请求头中的 content-type
// 告诉一下服务端我给你的是一个什么样子的数据格式 
xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded')
// 请求体直接再 send 的时候写在 () 里面就行
// 不需要问号，直接就是 'key=value&key=value' 的形式 xhr.send('a=100&b=200')

// 1. 创建 ajax 对象
let xhr = new XMLHttpRequest()
// 2. 配置请求信息 xhr.open(‘GET’, ‘./test.php’, true)
// 3. 发送请求 xhr.send()
// 4. 接受响应 
xhr.onload = function () {
    console.log(xhr.responseText) 
}








