Vue3 

Vue2内部的变量感觉要么从this获取，要么从event获取
Vue3不同，更多的需要写函数，还得记得返回

项目都是用的 element-ui，作为一个子组件，那么其实就会有很多的props，还有子组件返回的数据，子给父就可以有自定义事件，全局事件总线，消息订阅与发布这些方式，熟练掌握
还有对子组件的样式调整，定位、大小、旋转、位移这些
在复杂结构下的CSS也要看着调整


Vite创建项目
【基于 vite 创建】(推荐)

main.js中进行根组件的创建和挂载
import './assets/main.css'

// 引入创世神，应该相当于 new Vue()
import { createApp } from 'vue'
// 引入根组件 App
import App from './App.vue'

// 创建VM VC对象（App根组件对应的对象），并绑定到页面上
createApp(App).mount('#app')


Vue3中的数据和方法都是在setup()中进行编写的
setup函数返回的对象中的内容，可直接在模板中使用。
setup中访问this是undefined。
setup函数会在beforeCreate之前调用，它是“领先”所有钩子执行的。
如果在setup(){}中编写代码，最后需要进行return {}，对象中写所有要暴露的属性和方法

setup 与 Options API 的关系
Vue2 的配置（data、methos......）中可以访问到 setup中的属性、方法。
但在setup中不能访问到Vue2的配置（data、methos......）。
如果与Vue2冲突，则setup优先。

setup函数有一个语法糖，这个语法糖，可以让我们把setup独立出去，代码如下：
<script setup lang="ts" name="Person">
</script>

扩展：上述代码，还需要编写一个不写setup的script标签，去指定组件名字，比较麻烦，我们可以借助vite中的插件简化

第一步：npm i vite-plugin-vue-setup-extend -D
第二步：vite.config.ts

import { defineConfig } from 'vite'
import VueSetupExtend from 'vite-plugin-vue-setup-extend'

export default defineConfig({
  plugins: [ VueSetupExtend() ]
})


【ref 创建：基本类型的响应式数据】
可用ref包裹基本类型和对象类型，这样Vue就会对数据进行代理和劫持
但是需要通过 XXX.value 的方式获取和修改（无论是基本类型还是对象类型）

【reactive 创建：对象类型的响应式数据】
reactive包裹对象类型的数据，进行深层次的代理和劫持
reactive重新分配一个新对象，会失去响应式（可以使用Object.assign去整体替换）。类似于这种情形
let person = reactive({
    name: 'fuck',
    age: 11
})
Object.assign(person, {name: 'shit', age: 321})


【toRefs 与 toRef】
// 解构赋值，name和age都会变成ref响应式，而且变化会引起person的数据变化
let {name, age} = toRefs(person)

// 单独的变成ref，而且变化会引起person的数据变化
let yearOld = toRef(person, 'age')
let yearOld1 = ref(person.age)  // 上下两个不是一个概念



【computed】挺重要
import { ref, reactive, computed} from 'vue'
let first = ref('')
let second = ref('')

// 计算属性：传入回调函数，返回值给那个计算属性，而且计算属性多次调用只会执行一次，不像方法调几次执行几次，所以尽量考虑计算属性
// 因为可能会有复杂的属性处理逻辑，所以要做好封装
// 简写
// let full = computed(()=> first.value + '-' + second.value)
// 这么定义的计算属性只读，不可修改
// let full = computed(()=> {
//     return first.value.slice(0, 2).toUpperCase() + '-' + second.value.slice(3)
// })

// 给出get，set实现可读写
let full = computed({
    get(){
        return first.value.slice(0, 2).toUpperCase() + '-' + second.value.slice(1)
    },
    set(val){
        first.value = val.split('-')[0]
        second.value = val.split('-')[1]
    },
})



【watch】挺重要
// 监视 情况一，监视【ref】定义的【基本类型数据】
const stopWatch = watch(sum, (new_val, old_val)=>{
    console.log(new_val, old_val);
    // 取消监视
    if(sum.value >= 10) stopWatch()     // 接收过来就可以停止监视
})

// 监视 情况二，监视【ref】定义的【对象类型】数据，监视的是对象整体的地址，如果要监视内部属性，需要手动开启深度监视
// watch参数 被监视的数据、监视的回调、配置对象（deep, immediate等）
const stopWatch = watch(person, (val1, val2)=>{
    // val1和val2的值在修改内部属性时，其实都一样的
    console.log(val1, val2);        
}, {
    deep: true,     // 开启深度监视
    // immediate: true    // 预先立即执行一次
})


// 监视 情况三，监视【reactive】定义的【对象类型】数据
// person是reactive定义的，默认开启了深度监控
const stopWatch = watch(person, (val1, val2)=>{
    // val1和val2的值在修改内部属性时，其实都一样的
    console.log(val1, val2);        
}, {
    // deep: true,
    // immediate: true
})


// 监视单个基本类型属性时，第一个参数必须是一个getter函数，即有返回值的，即返回那个要监视的属性
// 简写
// watch(()=>person.name, (new_val, old_val)=>{
// watch(()=>{ return person.name}, (new_val, old_val)=>{
//     console.log(new_val, old_val);
// })

// 监视对象属性中的对象属性时，也建议写成函数式，再配合深度监视
watch(() => person.cars, (new_val, old_val)=>{
    console.log(new_val, old_val);
}, {deep: true})


// 监视上述多个属性，就传入一个数组，对象中单个属性就是方法，不是内层的就直接写
watch([()=>person.name, ()=>person.cars.c1, person.cars], (new_val, old_val)=>{
    console.log(new_val, old_val);
}, {deep: true});


watchEffect：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。
// watchEffect实现，此时就会自动监视所有下面声明的属性
watchEffect(()=>{
    if (sum1.value >= 60 || sum2.value >= 80) console.log('fuck you');
    
})


3.11. 【标签的 ref 属性】

作用：用于注册模板引用。

用在普通DOM标签上，获取的是DOM节点。
h2 ref="title2">shit</h2>
<h3 ref="title1">damn</h3>

// 创建一个title2，用于存储ref标记的内容
let title2 = ref()
let title1 = ref() 

然后通过.value的方式获取DOM元素
title2.value
title1.value


用在组件标签上，获取的是组件实例对象。
子组件Person.vue中要使用defineExpose暴露内容
// 使用defineExpose将组件中的数据交给外部
  defineExpose({name,age})


【ts中定义接口，控制对象中的数据类型】

// 定义接口，限制Person对象的类型
export interface PersonInter {
    id: string,
    name: string,
    age: number
}

// export type Persons = Array<PersonInter>
// 这样写也可以
export type Persons = PersonInter[]


【props】挺重要
父组件给子组件传递数据时用
<Person msg1='fuck you' :personList="personList"></Person>

import { defineProps, withDefaults } from 'vue';

// 仅接收personList、msg，但是script中读取不到
// defineProps(['personList', 'msg'])

// 接收personList并加入类型显示，括号里面就不用再写了
// defineProps<{ personList: Persons, msg: string }>()

// 接收+限制类型+限制必要性（通过 ?: 来实现）+指定默认值
withDefaults(defineProps<{ personList: Persons, msg?: string }>(), {
    personList: ()=>[{id: '123', name: '123', age: 321}],
    msg: 'fuck shit'
})

// 接收并读取personList
// let props = defineProps(['personList'])
// console.log(props.personList);


【生命周期】挺重要

因为Vue3有了setup，所以创建都是最先完成的，setup要早于任何一个周期

// create，应该是setup就帮忙创建了？
console.log('created');

// 在onMounted和onBeforeUpdate之间
nextTick(()=>{
    console.log('nextTick'); 
})

onBeforeMount(()=>{
    console.log('onBeforeMount');
})

onMounted(()=>{
    console.log('onMounted'); 
})

onBeforeUpdate(()=>{
    console.log('onBeforeUpdate'); 
})

onUpdated(()=>{
    console.log('onUpdated'); 
})

onBeforeUnmount(()=>{
    console.log('onBeforeUnmount'); 
})

onUnmounted(()=>{
    console.log('onUnmounted'); 
})

// 大概是路由中的钩子
onActivated(()=>{})

onDeactivated(()=>{})

// 这个应该这么用的吧
nextTick(()=>{})


【自定义hook】应该是后面编码时的一些规范上的问题，某个功能用到的变量、函数集中放在一个ts中进行管理

示例代码：
useSum.ts中内容如下：

import {ref,onMounted} from 'vue'

export default function(){
  let sum = ref(0)

  const increment = ()=>{
    sum.value += 1
  }
  const decrement = ()=>{
    sum.value -= 1
  }
  onMounted(()=>{
    increment()
  })

  //向外部暴露数据
  return {sum,increment,decrement}
}

组件中
<script setup lang="ts">
  import useSum from './hooks/useSum'

  // 解构赋值
  let {sum,increment,decrement} = useSum()
  let {dogList,getDog} = useDog()
</script>


【路由】 非常重要:

1、导航区 展示区
2、请来路由器
3、指定路由的具体规则（什么路径，对应什么组件）
4、形成一个一个的 XXX.vue

通过点击导航，视觉效果上“消失” 了的路由组件，默认是被**卸载**掉的，需要的时候再去**挂载**。这个我也意识到了

最重要的就是路由的配置文件，和Vue2挺相像的，API有些变化

// 创建路由器，并向外暴露

import { createRouter, createWebHistory } from "vue-router";
import About from '@/pages/About.vue'
import Home from '@/pages/Home.vue'
import News from '@/pages/News.vue'


// 引入createRouter
const router =  createRouter({
    // history: createWebHistory(),  // 路由器的history工作模式，不会有#号
    history: createWebHashHistory(),  // 路由器的hash工作模式，会有#号，但是省心
    routes: [
        {
            name: 'about',    // 路由的名字
            path: '/about',
            component: About,
        },
        {
            name: 'home',
            path: '/home',
            component: Home,
        },
        {
            name: 'news',
            path: '/news',
            component: News,
            children: [     // 嵌套路由
                {
                    name: 'detail',
                    // path: 'detail', // query传参可以这样子
                    path: 'detail/:id/:title/:content',  // params传参
                    component: Detail,
                    // 对象写法，所有的属性都会以props的形式传给MessageContent
                    // props: {a: 1,b: 'fuckyou'}

                    // 布尔值写法
                    // 若为true，就会把所有收到的params参数以props的形式传给MessageContent
                    // props: true

                    // 函数写法
                    
                    props(route) {
                        // 竟然会自动解构赋值哦？不对，这是因为params本身就是对象了，这种写法写重复了
                        // return { id: route.params.id, title: route.params.title, content: route.params.content }
                        return route.params
                    }
                },
            ]

        },
        {
            path: '/',
            redirect: '/home',    // 重定向，解决一开始/路径没有配置任何组件的问题
        }

    ],
    
})


export default router


组件中要配置导航项：
点击进行路由跳转的
<RouterLink active-class="active" to="/home">Home</RouterLink>
路由挂载的区域
<RouterView></RouterView>

query和params参数，是通过路由路径进行传参，和Vue2大同小异
params要注意路由配置时的占位符
<!-- query参数 -->
<!-- <RouterLink :to="`/news/detail?id=${n.id}&title=${n.title}&content=${n.content}`">{{n.title}}</RouterLink> -->
<!-- <RouterLink :to="{
  name: 'detail',
  query: {
    id: n.id,
    title: n.title,
    content: n.content,
  }
}">{{n.title}}</RouterLink> -->

<!-- params参数 -->
<!-- <RouterLink :to="`/news/detail/${n.id}/${n.title}/${n.content}`">{{n.title}}</RouterLink> -->
<RouterLink :to="{
name: 'detail',
params: {
  id: n.id,
  title: n.title,
  content: n.content,
}
}">{{ n.title }}</RouterLink>


query和params参数的接收
<!-- query参数 -->
<!-- <li>{{ route.query.id }}</li>
<li>{{ route.query.title }}</li>
<li>{{ route.query.content }}</li> -->
<!-- params参数 -->
<!-- <li>{{ route.params.id }}</li>
<li>{{ route.params.title }}</li>
<li>{{ route.params.content }}</li> -->
<!-- 从路由的props传来？ -->

// 需要引入hooks useRoute
// import { useRoute } from 'vue-router';


props传参，路由配置文件需要配置，路由组件中要用defineProps()来接收
props传参的接收
<li>{{ id }}</li>
<li>{{ title }}</li>
<li>{{ content }}</li>


路由导航项上加replace属性，会造成不能浏览器历史后退的情况
<RouterLink replace active-class="active" to="/home">Home</RouterLink>
<RouterLink replace active-class="active" to="/about">About</RouterLink>


编程式路由导航 挺重要

和Vue2的在创建时绑定不同，Vue3是组合式的，函数式的，哪里需要就在哪里use
const router = useRouter()

function show(n: NewsDetail) {
  // 再通过router
  router.push({
    name: 'detail',
    params: {
      id: n.id,
      title: n.title,
      content: n.content,

    }
  })
}


【pinia】  一个挺厉害的hooks，可以实现潜意识的数据操作
在main.ts中
// 引入pinia
import {createPinia} from 'pinia'
// 创建pinia
const pinia = createPinia()
// 使用pinia
app.use(pinia)

【存储+读取数据】
Store是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它。

它有三个概念：state、getter、actions，相当于组件中的： data、 computed 和 methods。所以在获取属性的时候可以尝试this

具体编码：src/store/count.ts

// 引入defineStore用于创建store
import {defineStore} from 'pinia'

// 定义并暴露一个store
export const useCountStore = defineStore('count',{
  // 动作
  actions:{},
  // 状态
  state(){
    return {
      sum:6,
      // 完全可以写表达式，因为这个其实是呗包括在函数中的
      verseList: JSON.parse(localStorage.getItem('verse') as string) || [],
      talkList:[
        {id:'yuysada01',content:'你今天有点怪，哪里怪？怪好看的！'},
        {id:'yuysada02',content:'草莓、蓝莓、蔓越莓，你想我了没？'},
        {id:'yuysada03',content:'心里给你留了一块地，我的死心塌地'}
      ]
    }
  },
  // 计算
  getters:{}
})

组件中使用state中的数据

template>
  <h2>当前求和为：{{ sumStore.sum }}</h2>
</template>

<script setup lang="ts" name="Count">
  // 引入对应的useXxxxxStore
  import {useSumStore} from '@/store/sum'
  
  // 调用useXxxxxStore得到对应的store
  const sumStore = useSumStore()
</script>

【修改数据】(三种方式)
第一种修改方式，直接修改
countStore.sum = 666

// 第二种修改方式，数据多的时候
// numStore.$patch({
//     school: 'damn1',
//     addr: 'damn2'
// })

// 第三种修改方式，配置actions动作

import { defineStore } from 'pinia'

export const useCountStore = defineStore('count', {
  actions: {
    //加
    increment(value:number) {
      if (this.sum < 10) {
        //操作countStore中的sum
        this.sum += value
      }
    },
    //减
    decrement(value:number){
      if(this.sum > 1){
        this.sum -= value
      }
    }
  },
})

组件中调用action即可
// 使用countStore
const countStore = useCountStore()

// 调用对应action
countStore.incrementOdd(n.value)


【storeToRefs】
// 只会关注store中的数据，不会对方法进行ref操作
// 这样之后在HTML中就不用再 {{ XXX.XXX }}操作了，直接{{ XXX }}
const {num, school, addr, bigSum, upperSchool} = storeToRefs(numStore)


let verseStore = useVerseStore()
const {verseList} = storeToRefs(verseStore)

// 只要verse store里面你的数据发生了变化，就会调用回调函数
// state，pinia中的所有数据
verseStore.$subscribe((mutate, state)=>{
    // 确保数据不丢失，持久化存储下来
    localStorage.setItem('verse', JSON.stringify(state.verseList))
})


【store组合式写法】
也就是配置式的代码可以用组合式/函数式进行编写

import {defineStore} from 'pinia'
import axios from 'axios'
import {nanoid} from 'nanoid'
import {reactive} from 'vue'

export const useTalkStore = defineStore('talk',()=>{
  // talkList就是state
  const talkList = reactive(
    JSON.parse(localStorage.getItem('talkList') as string) || []
  )

  // getATalk函数相当于action
  async function getATalk(){
    // 发请求，下面这行的写法是：连续解构赋值+重命名
    let {data:{content:title}} = await axios.get('https://api.uomg.com/api/rand.qinghua?format=json')
    // 把请求回来的字符串，包装成一个对象
    let obj = {id:nanoid(),title}
    // 放到数组中
    talkList.unshift(obj)
  }
  
  // 最后要记得return
  return {talkList,getATalk}
})


组件通信 这就特别重要了，父子 子父 任意 祖孙 孙祖

Vue3组件通信和Vue2的区别：

移出事件总线，使用mitt代替。
vuex换成了pinia。
把.sync优化到了v-model里面了。
把$listeners所有的东西，合并到$attrs中了。
$children被砍掉了。

父子：
props     
v-model
$refs
默认插槽、具名插槽

子父
props    通过绑定函数，然后通过函数的参数拿到
自定义事件    感觉是子传父最好的方式
v-model
$parent
作用域插槽

祖孙 孙祖
$attrs
provide inject

任意
mitt    全局事件总线
pinia    高级hooks


【props】
若 父传子：属性值是非函数。
若 子传父：属性值是函数。

<template>
  <div class="father">
    <h3>父组件，</h3>
        <h4>我的车：{{ car }}</h4>
        <h4>儿子给的玩具：{{ toy }}</h4>
        <Child :car="car" :getToy="getToy"/>
  </div>
</template>

<script setup lang="ts" name="Father">
    import Child from './Child.vue'
    import { ref } from "vue";
    // 数据
    const car = ref('奔驰')
    const toy = ref()
    // 方法
    function getToy(value:string){
        toy.value = value
    }
</script>


<template>
  <div class="child">
    <h3>子组件</h3>
        <h4>我的玩具：{{ toy }}</h4>
        <h4>父给我的车：{{ car }}</h4>
        <button @click="getToy(toy)">玩具给父亲</button>
  </div>
</template>

<script setup lang="ts" name="Child">
    import { ref } from "vue";
    const toy = ref('奥特曼')
    
    defineProps(['car','getToy'])
</script>


【自定义事件】

原生事件对象$event: 是包含事件相关信息的对象（pageX、pageY、target、keyCode）
自定义事件对象$event: 是调用emit时所提供的数据，可以是任意类型！！！


<!--在父组件中，给子组件绑定自定义事件：-->
<Child @send-toy="toy = $event"/>
<Child @send-toy="toy = $event"/>

<!--注意区分原生事件与自定义事件中的$event-->
<button @click="toy = $event">测试</button>

//子组件中，触发事件：
this.$emit('send-toy', 具体数据)


【mitt】

概述：与消息订阅与发布（pubsub）功能类似，可以实现任意组件间通信。

新建文件：src\utils\emitter.ts

// 引入mitt 
import mitt from "mitt";

// 创建emitter
const emitter = mitt()

/*
  // 绑定事件   全局事件
  emitter.on('abc',(value)=>{
    console.log('abc事件被触发',value)
  })
  emitter.on('xyz',(value)=>{
    console.log('xyz事件被触发',value)
  })

  setInterval(() => {
    // 触发事件
    emitter.emit('abc',666)
    emitter.emit('xyz',777)
  }, 1000);

  setTimeout(() => {
    // 清理事件
    emitter.all.clear()
  }, 3000); 
*/

// 创建并暴露mitt
export default emitter


接收数据的组件中：绑定事件、同时在销毁（生命周期）前解绑事件：

import emitter from "@/utils/emitter";
import { onUnmounted } from "vue";

// 绑定事件
emitter.on('send-toy',(value)=>{
  console.log('send-toy事件被触发',value)
})

onUnmounted(()=>{
  // 解绑事件
  emitter.off('send-toy')
})


【第三步】：提供数据的组件，在合适的时候触发事件

import emitter from "@/utils/emitter";

function sendToy(){
  // 触发事件
  emitter.emit('send-toy',toy.value)
}


【v-model】

概述：实现 父↔子 之间相互通信。


【$attrs 】
祖→孙

$attrs是一个对象，包含所有父组件传入的标签属性。

<template>
  <div class="father">
    <h3>父组件</h3>
        <Child :a="a" :b="b" :c="c" :d="d" v-bind="{x:100,y:200}" :updateA="updateA"/>
  </div>
</template>

<script setup lang="ts" name="Father">
    import Child from './Child.vue'
    import { ref } from "vue";
    let a = ref(1)
    let b = ref(2)
    let c = ref(3)
    let d = ref(4)

    function updateA(value){
        a.value = value
    }
</script>

<template>
    <div class="child">
        <h3>子组件</h3>
        <GrandChild v-bind="$attrs"/>
    </div>
</template>

<script setup lang="ts" name="Child">
    import GrandChild from './GrandChild.vue'
</script>

<template>
    <div class="grand-child">
        <h3>孙组件</h3>
        <h4>a：{{ a }}</h4>
        <h4>b：{{ b }}</h4>
        <h4>c：{{ c }}</h4>
        <h4>d：{{ d }}</h4>
        <h4>x：{{ x }}</h4>
        <h4>y：{{ y }}</h4>
        <button @click="updateA(666)">点我更新A</button>
    </div>
</template>

<script setup lang="ts" name="GrandChild">
    defineProps(['a','b','c','d','x','y','updateA'])
</script>


【$refs、$parent】

$refs用于 ：父→子。
$parent用于：子→父。

$refs        值为对象，包含所有被ref属性标识的DOM元素或组件实例。
$parent      值为对象，当前组件的父组件实例对象。

<template>
    <div class="father">
        <h3>父组件</h3>
        <h4>房产：{{ house }}</h4>
        <button @click="changeToy">修改Child1的玩具</button>
        <button @click="changeComputer">修改Child2的电脑</button>
        <button @click="getAllChild($refs)">让所有孩子的书变多</button>
        <Child1 ref="c1"/>
        <Child2 ref="c2"/>
    </div>
</template>

    let c1 = ref()
    let c2 = ref()

// 数据
    let house = ref(4)
    // 方法
    function changeToy(){
        // 简直就是直接操作数据
        c1.value.toy = '小猪佩奇'
    }
    function changeComputer(){
        c2.value.computer = '华为'
    }
    function getAllChild(refs:{[key:string]:any}){
        console.log(refs)
        for (let key in refs){
            // 对象.属性的另一种写法 对象[属性]
            refs[key].book += 3
            // 这个会变不了的
            // refs.key.book += 3
        }
    }
    // 向外部提供数据，这个不能少，ref用在组件上时，必须在最后有这个才能拿到数据
    defineExpose({house})

<template>
  <div class="child1">
    <h3>子组件1</h3>
        <h4>玩具：{{ toy }}</h4>
        <h4>书籍：{{ book }} 本</h4>
        <button @click="minusHouse($parent)">干掉父亲的一套房产</button>
  </div>
</template>

// 方法
    function minusHouse(parent:any){
        parent.house -= 1   // 有了$parent就能直接拿到父组件，从子组件中对父组件中数据直接进行操作
    }

    // 把数据交给外部
    defineExpose({toy,book})


【provide、inject】
概述：实现祖孙组件直接通信

具体使用：

在祖先组件中通过provide配置向后代组件提供数据
在后代组件中通过inject配置来声明接收数据

// 父组件向后代提供数据
provide('moneyContext',{money,updateMoney})
provide('car',car)

//孙组件直接接收，updateMoney是祖先的一个方法，孙组件拿到之后调用，参数会回传给祖先，间接实现孙组件修改祖先数据
let {money,updateMoney} = inject('moneyContext',{money:0,updateMoney:(param:number)=>{}})
let car = inject('car',{brand:'未知',price:0})


【pinia】 高级hooks


【slot】 挺重要

1. 默认插槽

父组件中：
<Category title="今日热门游戏">
  <ul>
    <li v-for="g in games" :key="g.id">{{ g.name }}</li>
  </ul>
</Category>
子组件中：
<template>
  <div class="item">
    <h3>{{ title }}</h3>
    <!-- 默认插槽 -->
    <slot></slot>
  </div>
</template>


2. 具名插槽

父组件中：
<Category title="今日热门游戏">
  <template #s2>
    <a href="">更多</a>
  </template>
    // 根据具体的名字对应插入
    <template v-slot:s1>
    <ul>
      <li v-for="g in games" :key="g.id">{{ g.name }}</li>
    </ul>
  </template>
</Category>

子组件中：
<template>
  <div class="item">
    <h3>{{ title }}</h3>
    <slot name="s1"></slot>
    <slot name="s2"></slot>
  </div>
</template>

3. 作用域插槽
理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（新闻数据在News组件中，但使用数据所遍历出来的结构由App组件决定）

父组件中：
注意这里是 v-slot="XXX" 此时XXX会获得子组件slot上绑定的所有参数
<Game v-slot="params">
<!-- <Game v-slot:default="params"> -->
<!-- <Game #default="params"> -->
  <ul>
    <li v-for="g in params.games" :key="g.id">{{ g.name }}</li>
  </ul>
</Game>

子组件中：
<template>
  <div class="category">
    <h2>今日游戏榜单</h2>
    <slot :games="games" a="哈哈"></slot>
  </div>
</template>

<script setup lang="ts" name="Category">
  import {reactive} from 'vue'
  let games = reactive([
    {id:'asgdytsa01',name:'英雄联盟'},
    {id:'asgdytsa02',name:'王者荣耀'},
    {id:'asgdytsa03',name:'红色警戒'},
    {id:'asgdytsa04',name:'斗罗大陆'}
  ])
</script>


【shallowRef 与 shallowReactive 】

hallowRef
作用：创建一个响应式数据，但只对顶层属性进行响应式处理。

用法：
let myVar = shallowRef(initialValue);
特点：只跟踪引用值的变化，不关心值内部的属性变化。

shallowReactive
作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的

用法：
const myObj = shallowReactive({ ... });
特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。

总结：
通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。


【readonly 与 shallowReadonly】
readonly
作用：用于创建一个对象的深只读副本。

用法：

const original = reactive({ ... });
const readOnlyCopy = readonly(original);
特点：

对象的所有嵌套属性都将变为只读。
任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。
应用场景：

创建不可变的状态快照。
保护全局状态或配置不被修改。


shallowReadonly
作用：与 readonly 类似，但只作用于对象的顶层属性。

用法：

const original = reactive({ ... });
const shallowReadOnlyCopy = shallowReadonly(original);
特点：

只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。

适用于只需保护对象顶层属性的场景。


【toRaw 与 markRaw】

toRaw
作用：用于获取一个响应式对象的原始对象， toRaw 返回的对象不再是响应式的，不会触发视图更新。

何时使用？ —— 在需要将响应式对象传递给非 Vue 的库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象

import { reactive,toRaw,markRaw,isReactive } from "vue";

/* toRaw */
// 响应式对象
let person = reactive({name:'tony',age:18})
// 原始对象
let rawPerson = toRaw(person)


/* markRaw */
let citysd = markRaw([
  {id:'asdda01',name:'北京'},
  {id:'asdda02',name:'上海'},
  {id:'asdda03',name:'天津'},
  {id:'asdda04',name:'重庆'}
])
// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了
let citys2 = reactive(citys)
console.log(isReactive(person))
console.log(isReactive(rawPerson))
console.log(isReactive(citys))
console.log(isReactive(citys2))

markRaw
作用：标记一个对象，使其永远不会变成响应式的。
例如使用mockjs时，为了防止误把mockjs变为响应式对象，可以使用 markRaw 去标记mockjs

/* markRaw */
let citys = markRaw([
  {id:'asdda01',name:'北京'},
  {id:'asdda02',name:'上海'},
  {id:'asdda03',name:'天津'},
  {id:'asdda04',name:'重庆'}
])
// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了
let citys2 = reactive(citys)


【customRef】
作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行逻辑控制。

实现防抖效果（useSumRef.ts）：

import {customRef } from "vue";

export default function(initValue:string,delay:number){
  let msg = customRef((track,trigger)=>{
    let timer:number
    return {
      get(){
        track() // 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新
        return initValue
      },
      set(value){
        clearTimeout(timer)
        timer = setTimeout(() => {
          initValue = value
          trigger() //通知Vue数据msg变化了
        }, delay);
      }
    }
  }) 
  return {msg}
}


8. Vue3新组件

【Teleport】

什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。
<teleport to='body' >
    <div class="modal" v-show="isShow">
      <h2>我是一个弹窗</h2>
      <p>我是弹窗中的一些内容</p>
      <button @click="isShow = false">关闭弹窗</button>
    </div>
</teleport>


【Suspense】
等待异步组件时渲染一些额外内容，让应用有更好的用户体验
使用步骤：
异步引入组件
使用Suspense包裹组件，并配置好default 与 fallback

import { defineAsyncComponent,Suspense } from "vue";
const Child = defineAsyncComponent(()=>import('./Child.vue'))

<template>
    <div class="app">
        <h3>我是App组件</h3>
        <Suspense>
<!-- 这两个要么一起用，要么只能用default，fallback单独用不起任何效果 -->
          <template v-slot:default>
            <Child/>
          </template>
          <template v-slot:fallback>
            <h3>加载中.......</h3>
          </template>
        </Suspense>
    </div>
</template>



【全局API转移到应用对象】
app.component   
app.config
app.directive
app.mount
app.unmount
app.use

main.ts中
// 全局组件，后面的不用再引用了，直接<Hello/>就可以了
app.component('Hello',Hello)

// 配置全局属性，在所有组件上都可以用{{ x }}或者"x" 了
app.config.globalProperties.x = 99

declare module 'vue' {
  interface ComponentCustomProperties {
    x:number
  }
}
app.directive('beauty',(element,{value})=>{
  element.innerText += value
  element.style.color = 'green'
  element.style.backgroundColor = 'yellow'
})





同步异步









































