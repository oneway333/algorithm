vue

数据代理，数据劫持？
Vue是怎样实现数据监视的？应该也就是通过给每个属性（无论是字面量、函数、对象）套上set get方法，获取的时候都需要调用set和get方法。这样在get和set中就有那么一段神奇的逻辑，监视着这些数据的变化，然后来渲染页面

双大括号
{{js表达式}}
可以写{{data中的属性}}，{{n++}}, {{}}

adfasdfasdfasdfsfdf

@click="showInfo"    // 双引号里面也可以写js表达式
@click="showInfo1($event, 321)"  // 回调函数可以配置多个参数，事件对象要加$event
class="basic" :class="class_style1"    // 绑定样式
<h2 :style="{opacity:1}">fuck you</h2>    // 通过style绑定样式，要用对象形式的写法

一般结构：

body中：

<div id="root">
</div>

script中：
new Vue({
    el:'#root',
    data: {
        name: 'fuck',    // 绑定的属性变量
        class_style1: [],   // 样式的数组
        class_style2: {css1: true, css2:false},   // 样式的对象
    },
    methods: {
        // 事件的回调函数，和js一样，会传入事件对象，用法相同
        showInfo1(e){
            console.log(e.target);
            console.log(e.target.textContent);
        },
        showInfo2:(e) => { 
            console.log(this); // this指向window，所以尽量不要使用箭头函数
        },
        showInfo3(e, num){
            console.log(num);  // 回调函数可以配置多个参数，此处可以接收
        },
        change_mood(){
            this.class_style1.push('fuck1')    // 将这些样式添加进class中
            this.class_style1.push('fuck2')
            this.class_style1.push('fuck3')
        }
    },
    computed: {    // 计算属性
        full1: {
            get(){
                return this.fuck + '-' + this.you   // 通过this拿到data中的数据，需要return
            },
            // 当full被修改时调用，要传入一个val值
            set(val){
                // 要改data中的数据全都要改
                let t = val.split('-')
                this.fuck = t[0]
                this.you = t[1]
            }
        },
        full2(){    // 计算属性通常只会get，所以这是只有get功能的简写形式
            return 'XXX'
        }
    },
    // 计算属性更适合属性是由其他属性变化而来的情况
    // 计算属性一开始就会执行，不会出现监视属性第一次不执行的情况
    // 监视适合对当前属性的变化进行监视，从而影响其他的属性（好像也没说明白）
    watch: {
        name1: {
            deep:true,  // 深度监视，当name为obj的时候，其中的每个属性变化都会触发
            immediate: true,    // 在handler执行之前会执行一次
            handler(new_val, old_val){    // 两个参数，也可以传入一个参数，一个参数就是new_val
                console.log(new_val, old_val);
            }
        },
        // 当不需要配置除了handler之外的其他属性的时候可以采取简写形式
        name2(new_val, old_val) {
            console.log(new_val, old_val);
        }
    },
    
    
})


指令
v-bind      单向数据绑定，数据变但是data不变，v-bind:XXX="XXX" 简写 :XXX="xxxx"
v-model     双向数据绑定，数据变data也变，v-model:value="XXX" 简写 v-model="xxxx"    
            一般用于input中绑定value
            input为radio时的数据绑定：
             <input type="radio" name="gender" v-model="gender" value="male">
             
            input为checkbox时的数据绑定：
            <input type="checkbox" v-model="hobby" value="fuck1">
            
            select的数据绑定：
            <select v-model="city">
            
            textarea的数据绑定，lazy修饰符表示当textares失去焦点时更新vue的data：
            <textarea v-model.lazy="other" v-model="other">
            
            单个checkbox中，v-model绑定的是checked，默认为false
            <input type="checkbox" v-model="agree">
            
            绑定表单提交的事件，pervent阻止默认事件的修饰符
            <form action="" @submit.prevent="demo">
            
            
            
v-for       列表渲染：(element, index) of/in arr/obj/str/num  相当神奇的写法
            key的数据绑定是为了diff算法优化数据刷新的逻辑
            <ul v-for="p of persons" :key="p.id/index">
            <li>
                {{p.name}}-{{p.age}}-{{p.id}}
                <input type="text">    <!-- 如果有key属性，input中的值会进行保留，也就是diff算法的优化 -->
            </li>
            </ul>


v-on        事件处理：v-on:click="XXX"，简写：@click="XXX"
            修饰符：.prevent 阻止默认事件   
                    .stop 阻止冒泡    
                    .once 只发生一次
            键盘事件：@keyup @keydown, tab这种有默认效果的，最好用keydown


v-show      是否展示，相当于display: none
v-if        主要是会删除节点，相当于 DPM中的 element.remove()
v-else-if   成立必须当前节点的上一个兄弟节点有v-if修饰，因此下方div之间不能有除了空白节点之外的任何东西
v-else

v-text      将内容完全当文本插入标签中，怀疑用的是textContent
            name='shit'
            <h1 v-text="name">fuck</h1>
v-html      将内容解析为标签插入到内容中
            str: "<h2>damn</h2>"
            <h1 v-html="str">fuck</h1>
v-cloak     v-cloak结合CSS属性，来实现Vue未渲染时，元素不显示，当渲染时再显示
            <style>
                [v-cloak]{    // 属性选择器
                    display: none;
                }
            </style>
            <h1 v-cloak>{{name}}</h1>
v-once      此处n只会变化一次，n=1
            <h2 v-once>initial n: {{n}}</h2>
v-pre       跳过所在节点的编译过程，达到快速编译
            <h2 v-pre>fuck you</h2>





一些实例应用：

列表过滤  模糊搜索  用计算属性定义一个属性指向原来的内容属性，通过数组的方法来实现
computed: {
              bakPersons: {
                  get() {    // 必须是函数表达式
                      return this.persons.filter(p => p.name.includes(this.search))
                  }
              }
          }

列表的排序 通过数组的方法来实现 sortType作为不同排序的index
computed: {
    bakPersons(){
        const t = this.persons.filter(p => p.name.includes(this.search))
        // 操作数组中的对象时的sort
        if (this.sortType == 2) return t.sort((a, b) => a.age - b.age)
        else if (this.sortType == 1) return t.sort((a, b) => b.age - a.age)
        else return t
    }                
}



 